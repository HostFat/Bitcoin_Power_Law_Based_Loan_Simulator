<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bitcoin Financial Strategy Simulator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .chart-container { position: relative; width: 100%; height: 40vh; max-height: 500px; }
    @media (min-width: 768px) { .chart-container { height: 60vh; } }
    input[type="range"] { width: 100%; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #0d9488; cursor: pointer; border-radius: 50%; }
    input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #0d9488; cursor: pointer; border-radius: 50%; }
    .mode-button { padding: 0.5rem 1rem; border: 1px solid #cbd5e1; color: #64748b; cursor: pointer; transition: all 0.2s; }
    .mode-button.active { background-color: #0d9488; color: white; border-color: #0d9488; font-weight: 600; }
    .number-input { width: 100%; }
    .row-red { background-color: #fee2e2; }
    .hidden { display: none; }
    #powerLawInfoBox a { color: #0d9488; text-decoration: underline; }
    #powerLawInfoBox ul { list-style: disc; padding-left: 1.25rem; }
  </style>
</head>
<body class="bg-stone-50 text-slate-800">

  <div class="container mx-auto p-4 sm:p-6 lg:p-8">
    <header class="mb-8">
      <div class="text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-teal-800">Bitcoin Power Law Based Simulator</h1>
        <p class="mt-2 text-slate-600">An interactive tool to explore financial strategies based on a long-term Bitcoin growth model.</p>
      </div>
    </header>

    <section class="mb-8">
      <div id="powerLawInfoBox" class="bg-white p-6 rounded-xl shadow-md border border-stone-200">
        <h3 class="text-xl font-semibold mb-3 text-slate-700">What is the Power Law Support Line?</h3>
        <div id="powerLawInfoContent" class="text-sm text-slate-600 space-y-3">
          <p>The 'Power Law Support Line' is a mathematical model that plots a historical support level for Bitcoin's price over time. This simulator uses this formula to project a future support value for BTC.</p>
          <p><strong>Formula:</strong> <code>Support Price = (1.0117e-17 × days_since_genesis^5.82) × 0.42</code></p>
          <div>
            <strong>Sources:</strong>
            <ul>
              <li><a href="https://giovannisantostasi.medium.com/the-bitcoin-power-law-theory-962dfaf99ee9" target="_blank" rel="noopener noreferrer">The Bitcoin Power Law Theory (Giovanni Santostasi)</a></li>
              <li><a href="https://charts.bitbo.io/long-term-power-law/" target="_blank" rel="noopener noreferrer">Bitbo: Long-term Power Law chart</a></li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <aside class="lg:col-span-1 flex flex-col gap-8">
        <div class="bg-white p-6 rounded-xl shadow-md border border-stone-200">
          <h2 class="text-2xl font-semibold mb-4 text-slate-700">Simulation Parameters</h2>

          <div class="space-y-6">
            <div>
              <label class="block font-medium text-slate-600 mb-2">Strategy</label>
              <div class="flex rounded-md shadow-sm">
                <button type="button" id="modeLoan" class="mode-button rounded-l-md active">Loan</button>
                <button type="button" id="modeSell" class="mode-button rounded-r-md -ml-px">Sell</button>
              </div>
            </div>

            <div>
              <label id="btcAmountLabel" for="btcAmount" class="block font-medium text-slate-600 cursor-pointer">BTC for Collateral</label>
              <div class="flex items-center space-x-2 mt-1">
                <input type="number" id="btcAmount" value="1.00000000" step="0.00000001" min="0" max="1000000" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500">
                <button type="button" id="calculateSafeCollateralBtn" class="px-3 py-2 bg-teal-600 text-white rounded-md shadow-sm hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 text-sm whitespace-nowrap">
                  Calculate Safe BTC
                </button>
              </div>
            </div>

            <!-- Annual Inflation Rate shown always right after BTC -->
            <div>
              <label for="inflationRate" class="block font-medium text-slate-600">
                Annual Inflation Rate: <span id="inflationRateValue" class="font-bold text-teal-700">7.0</span>%
              </label>
              <input type="range" id="inflationRate" min="0" max="20" step="0.1" value="7" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600">
            </div>

            <div id="loanParams">
              <div class="space-y-6">
                <div>
                  <label for="ltv" class="block font-medium text-slate-600">
                    Loan-to-Value (LTV): <span id="ltvValue" class="font-bold text-teal-700">70</span>%
                  </label>
                  <input type="range" id="ltv" min="10" max="90" step="1" value="70" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600">
                </div>
                <div>
                  <label for="interestRate" class="block font-medium text-slate-600">
                    Annual Interest Rate: <span id="interestRateValue" class="font-bold text-teal-700">7.0</span>%
                  </label>
                  <input type="range" id="interestRate" min="0" max="20" step="0.5" value="7" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600">
                </div>

                <!-- Withdrawal Strategy Toggle -->
                <div>
                  <label class="block font-medium text-slate-600 mb-2">Withdrawal Strategy</label>
                  <div class="flex rounded-md shadow-sm">
                    <button type="button" id="modeFixedWithdrawal" class="mode-button rounded-l-md active">Fixed</button>
                    <button type="button" id="modeOptimizedWithdrawal" class="mode-button rounded-r-md -ml-px">Optimized</button>
                  </div>
                </div>

              </div>
            </div>

            <!-- Fixed Withdrawal Controls -->
            <div id="fixedWithdrawalControls">
              <label for="annualWithdrawal" class="block font-medium text-slate-600">Annual Withdrawal ($)</label>
              <div class="flex items-center space-x-2 mt-1">
                <input type="number" id="annualWithdrawal" value="10000" step="100" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500">
                <button type="button" id="calculateSafeWithdrawalBtn" class="px-3 py-2 bg-teal-600 text-white rounded-md shadow-sm hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 text-sm whitespace-nowrap">Calculate Safe Amount</button>
              </div>
            </div>

            <!-- Optimized Withdrawal Controls -->
            <div id="optimizedWithdrawalControls" class="hidden">
              <div class="space-y-4">
                <div>
                  <label for="safetyMargin" class="block font-medium text-slate-600">
                    Safety Margin: <span id="safetyMarginValue" class="font-bold text-teal-700">5.0</span>%
                  </label>
                  <div class="flex items-center space-x-2 mt-1">
                    <input type="range" id="safetyMargin" min="0" max="100" step="0.5" value="5" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600">
                    <button type="button" id="maximizeSafetyMarginBtn" class="px-3 py-2 bg-amber-600 text-white rounded-md shadow-sm hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 text-sm whitespace-nowrap text-center">
                      <div class="font-medium">Maximize</div>
                      <div class="text-xs opacity-80">Wait a little</div>
                    </button>
                  </div>
                  <p class="text-xs text-slate-500 mt-1">Reduces max withdrawal capacity by this percentage to avoid liquidation risk. 5% = use only 95% of available capacity.</p>
                </div>

                <div>
                  <label for="minWithdrawal" class="block font-medium text-slate-600">Minimum Withdrawal ($)</label>
                  <input type="number" id="minWithdrawal" value="0" step="100" min="0" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500 mt-1">
                  <p class="text-xs text-slate-500 mt-1">Minimum annual withdrawal amount. Optimized withdrawals will never go below this value.</p>
                </div>
              </div>
            </div>

            <div>
              <label for="startYear" class="block font-medium text-slate-600">
                Simulate From Year: <span id="startYearValue" class="font-bold text-teal-700">2025</span>
              </label>
              <input type="range" id="startYear" min="2025" max="2084" step="1" value="2025" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600">
            </div>

            <div>
              <label for="endYear" class="block font-medium text-slate-600">
                Simulate Until Year: <span id="endYearValue" class="font-bold text-teal-700">2085</span>
              </label>
              <input type="range" id="endYear" min="2026" max="2085" step="1" value="2085" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600">
            </div>

            <div id="targetContainer" class="mt-2">
              <label for="targetUnusedVsPeakFinal" class="block font-medium text-slate-600">
                Unused BTC vs Peak at final year (target)
              </label>
              <input type="number" id="targetUnusedVsPeakFinal" value="0.00000000" step="0.00000001" min="-1000000" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500">
              <p id="targetDescription" class="text-xs text-slate-500 mt-1">Shows BTC not used as collateral in the final year. Edit to require a target; BTC for Collateral = peak + target.</p>
            </div>

          </div>
        </div>
      </aside>

      <section class="lg:col-span-2 flex flex-col gap-8">
        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg border border-stone-200">
          <h2 id="chartTitle" class="text-2xl font-semibold mb-4 text-center text-slate-700">Debt vs. Capacity Projection</h2>
          <div class="chart-container"><canvas id="mainChart"></canvas></div>
        </div>
      </section>
    </main>

    <section class="mt-8">
      <div class="bg-white rounded-xl shadow-lg border border-stone-200 overflow-hidden">
        <div class="flex justify-between items-baseline p-6 border-b">
          <h2 id="tableTitle" class="text-2xl font-semibold text-slate-700"></h2>
          <p id="tableSubtitle" class="text-base font-medium text-blue-800 whitespace-nowrap"></p>
        </div>
        <div class="overflow-x-auto">
          <table class="w-full text-sm text-left text-slate-500">
            <thead id="resultsTableHeader" class="text-xs text-slate-700 uppercase bg-stone-100"></thead>
            <tbody id="resultsTableBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <footer class="mt-12 bg-rose-50 border border-rose-200 text-rose-800 p-6 rounded-xl shadow-md">
      <h2 class="text-2xl font-bold mb-3 flex items-center"><span class="text-3xl mr-3">☢️</span><span>Fundamental Warnings and Risks</span></h2>
      <div class="space-y-3 text-rose-700">
        <p><strong>This tool is a purely educational simulation and does NOT constitute financial advice.</strong></p>
        <p><strong>Liquidation Risk:</strong> If the market price of Bitcoin drops, your real LTV will increase. The lender may liquidate (sell) your collateral to repay the loan, causing the permanent loss of your Bitcoin.</p>
        <p><strong>Extreme Volatility:</strong> The Power Law model is a long-term trend and ignores short- and medium-term volatility. The actual price can deviate significantly from the forecast.</p>
        <p><strong>Model Reliability:</strong> There is no guarantee that Bitcoin's price will continue to follow this model in the future.</p>
      </div>
    </footer>
  </div>

<script>
  // DOM
  const modeLoanBtn = document.getElementById('modeLoan');
  const modeSellBtn = document.getElementById('modeSell');
  const modeFixedWithdrawalBtn = document.getElementById('modeFixedWithdrawal');
  const modeOptimizedWithdrawalBtn = document.getElementById('modeOptimizedWithdrawal');
  const btcAmountInput = document.getElementById('btcAmount');
  const ltvInput = document.getElementById('ltv');
  const interestRateInput = document.getElementById('interestRate');
  const inflationRateInput = document.getElementById('inflationRate');
  const annualWithdrawalInput = document.getElementById('annualWithdrawal');
  const safetyMarginInput = document.getElementById('safetyMargin');
  const minWithdrawalInput = document.getElementById('minWithdrawal');
  const maximizeSafetyMarginBtn = document.getElementById('maximizeSafetyMarginBtn');
  const startYearInput = document.getElementById('startYear');
  const endYearInput = document.getElementById('endYear');
  const startYearValueSpan = document.getElementById('startYearValue');
  const endYearValueSpan = document.getElementById('endYearValue');
  const ltvValueSpan = document.getElementById('ltvValue');
  const interestRateValueSpan = document.getElementById('interestRateValue');
  const inflationRateValueSpan = document.getElementById('inflationRateValue');
  const safetyMarginValueSpan = document.getElementById('safetyMarginValue');
  const resultsTableHeader = document.getElementById('resultsTableHeader');
  const resultsTableBody = document.getElementById('resultsTableBody');
  const targetContainer = document.getElementById('targetContainer');
  const targetUnusedVsPeakFinalInput = document.getElementById('targetUnusedVsPeakFinal');
  const targetDescriptionEl = document.getElementById('targetDescription');
  const chartTitleEl = document.getElementById('chartTitle');
  const tableTitleEl = document.getElementById('tableTitle');
  const tableSubtitle = document.getElementById('tableSubtitle');
  const btcAmountLabel = document.getElementById('btcAmountLabel');
  const loanParams = document.getElementById('loanParams');
  const fixedWithdrawalControls = document.getElementById('fixedWithdrawalControls');
  const optimizedWithdrawalControls = document.getElementById('optimizedWithdrawalControls');
  const ctx = document.getElementById('mainChart').getContext('2d');

  // State
  const GENESIS_DATE = new Date('2009-01-03');
  let mainChart;
  let simulationMode = 'loan';
  let withdrawalMode = 'fixed'; // 'fixed' or 'optimized'

  // Utils
  function formatCurrency(value) { return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value); }
  function formatBTC(value) { return (isFinite(value) ? value : 0).toFixed(8) + ' BTC'; }
  function formatBTCPlain(value) { return (isFinite(value) ? value : 0).toFixed(8); }
  function powerLawPrice(days) { return (1.0117e-17 * Math.pow(days, 5.82)) * 0.42; }

  function initializeChart() {
    if (mainChart) mainChart.destroy();
    mainChart = new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        scales: {},
        plugins: { tooltip: { callbacks: {} } }
      }
    });
  }

  // Button label updater for Calculate Safe BTC
  function updateCalculateSafeBtcButtonLabel() {
    const btn = document.getElementById('calculateSafeCollateralBtn');
    if (!btn) return;

    if (simulationMode === 'loan' && withdrawalMode === 'optimized') {
      btn.innerHTML = `
        <div class="leading-tight text-center">
          <div class="font-medium">Calculate Safe BTC</div>
          <div class="text-xs opacity-80">Wait a little</div>
        </div>
      `;
    } else {
      btn.textContent = 'Calculate Safe BTC';
    }
  }

  // Core checks
  function runLoanUnsafeCheck(btcAmount, annualWithdrawal, startYear, simulationYears) {
    const ltvFrac = (parseInt(ltvInput.value) || 0) / 100;
    const interestRate = parseFloat(interestRateInput.value) || 0;
    const inflationRate = parseFloat(inflationRateInput.value) || 0;
    const EPS = 1e-9;

    let totalDebt = 0;
    for (let i = 0; i <= simulationYears; i++) {
      const date = new Date(startYear + i, 0, 1);
      const days = Math.floor((date - GENESIS_DATE) / 86400000);
      const price = powerLawPrice(days);
      const maxLoanPossible = price * btcAmount * ltvFrac;
      const withdrawal = annualWithdrawal * Math.pow(1 + (inflationRate / 100), i);
      totalDebt += withdrawal;
      totalDebt *= (1 + interestRate / 100);
      if (totalDebt - maxLoanPossible > EPS) return true;
    }
    return false;
  }

  function runSellDepleted(btcAmount, annualWithdrawal, startYear, simulationYears) {
    const inflationRate = parseFloat(inflationRateInput.value) || 0;
    let remainingBtc = btcAmount;
    for (let i = 0; i <= simulationYears; i++) {
      const date = new Date(startYear + i, 0, 1);
      const days = Math.floor((date - GENESIS_DATE) / 86400000);
      const price = powerLawPrice(days);
      const usd = annualWithdrawal * Math.pow(1 + (inflationRate / 100), i);
      const btcNeed = usd / price;
      if (remainingBtc < btcNeed - 1e-12) return true;
      remainingBtc -= btcNeed;
    }
    return false;
  }

  // Optimized unsafe check (for safe collateral in optimized)
  function runOptimizedLoanUnsafeCheck(btcAmount, startYear, simulationYears) {
    try {
      const ltvFrac = (parseInt(ltvInput.value) || 0) / 100;
      const interestRate = parseFloat(interestRateInput.value) || 0;
      const inflationRate = parseFloat(inflationRateInput.value) || 0;
      const safetyMargin = parseFloat(safetyMarginInput.value) || 0;
      const minWithdrawal = parseFloat(minWithdrawalInput.value) || 0;
      const safetyFactor = (100 - safetyMargin) / 100;
      const EPS = 1e-9;

      const withdrawals = [];
      let totalDebt = 0;

      for (let currentYear = 0; currentYear <= simulationYears; currentYear++) {
        // Binary search maximum withdrawal this year
        let maxWithdrawal = 0;
        let low = 0, high = 1e7;

        for (let iter = 0; iter < 50; iter++) {
          const testWithdrawal = (low + high) / 2;
          let testDebt = totalDebt;
          let wouldLiquidate = false;

          for (let futureYear = currentYear; futureYear <= simulationYears; futureYear++) {
            const date = new Date(startYear + futureYear, 0, 1);
            const days = Math.floor((date - GENESIS_DATE) / 86400000);
            const price = powerLawPrice(days);
            const maxCapacity = price * btcAmount * ltvFrac;

            const withdrawal = (futureYear === currentYear)
              ? testWithdrawal
              : (withdrawals[futureYear] || testWithdrawal);

            const adjustedWithdrawal = withdrawal * Math.pow(1 + (inflationRate / 100), futureYear);
            testDebt += adjustedWithdrawal;
            testDebt *= (1 + interestRate / 100);

            if (testDebt > maxCapacity + EPS) { wouldLiquidate = true; break; }
          }

          if (wouldLiquidate) { high = testWithdrawal; } else { maxWithdrawal = testWithdrawal; low = testWithdrawal; }
        }

        let safeWithdrawal = maxWithdrawal * safetyFactor;
        safeWithdrawal = Math.max(safeWithdrawal, minWithdrawal);
        withdrawals[currentYear] = safeWithdrawal;

        const adjustedWithdrawal = safeWithdrawal * Math.pow(1 + (inflationRate / 100), currentYear);
        totalDebt += adjustedWithdrawal;
        totalDebt *= (1 + interestRate / 100);

        const date = new Date(startYear + currentYear, 0, 1);
        const days = Math.floor((date - GENESIS_DATE) / 86400000);
        const price = powerLawPrice(days);
        const maxLoanPossible = price * btcAmount * ltvFrac;
        if (totalDebt > maxLoanPossible + EPS) return true;
      }

      return false;
    } catch {
      return true;
    }
  }

  // Optimized withdrawal calculator
  function calculateOptimizedWithdrawals(btcAmount, startYear, simulationYears, safetyMarginOverride = null, minWithdrawalOverride = null) {
    const ltvFrac = (parseInt(ltvInput.value) || 0) / 100;
    const interestRate = parseFloat(interestRateInput.value) || 0;
    const inflationRate = parseFloat(inflationRateInput.value) || 0;
    const safetyMargin = safetyMarginOverride !== null ? safetyMarginOverride : (parseFloat(safetyMarginInput.value) || 0);
    const minWithdrawal = minWithdrawalOverride !== null ? minWithdrawalOverride : (parseFloat(minWithdrawalInput.value) || 0);
    const safetyFactor = (100 - safetyMargin) / 100;

    const withdrawals = [];
    let totalDebt = 0;

    for (let currentYear = 0; currentYear <= simulationYears; currentYear++) {
      let maxWithdrawal = 0;
      let low = 0, high = 1e7;

      for (let iter = 0; iter < 50; iter++) {
        const testWithdrawal = (low + high) / 2;
        let testDebt = totalDebt;
        let wouldLiquidate = false;

        for (let futureYear = currentYear; futureYear <= simulationYears; futureYear++) {
          const date = new Date(startYear + futureYear, 0, 1);
          const days = Math.floor((date - GENESIS_DATE) / 86400000);
          const price = powerLawPrice(days);
          const maxCapacity = price * btcAmount * ltvFrac;

          const withdrawal = (futureYear === currentYear) ? testWithdrawal : (withdrawals[futureYear] || testWithdrawal);
          const adjustedWithdrawal = withdrawal * Math.pow(1 + (inflationRate / 100), futureYear);
          testDebt += adjustedWithdrawal;
          testDebt *= (1 + interestRate / 100);

          if (testDebt > maxCapacity + 1e-9) { wouldLiquidate = true; break; }
        }

        if (wouldLiquidate) high = testWithdrawal; else { maxWithdrawal = testWithdrawal; low = testWithdrawal; }
      }

      let safeWithdrawal = maxWithdrawal * safetyFactor;
      safeWithdrawal = Math.max(safeWithdrawal, minWithdrawal);
      withdrawals[currentYear] = safeWithdrawal;

      const adjustedWithdrawal = safeWithdrawal * Math.pow(1 + (inflationRate / 100), currentYear);
      totalDebt += adjustedWithdrawal;
      totalDebt *= (1 + interestRate / 100);
    }

    return withdrawals;
  }

  function calculateTotalExtracted(btcAmount, startYear, simulationYears, safetyMargin) {
    const inflationRate = parseFloat(inflationRateInput.value) || 0;
    try {
      const withdrawals = calculateOptimizedWithdrawals(btcAmount, startYear, simulationYears, safetyMargin);
      let totalExtracted = 0;
      for (let i = 0; i <= simulationYears; i++) {
        const adjustedWithdrawal = withdrawals[i] * Math.pow(1 + (inflationRate / 100), i);
        totalExtracted += adjustedWithdrawal;
      }
      return totalExtracted;
    } catch {
      return 0;
    }
  }

  function maximizeSafetyMargin() {
    if (simulationMode !== 'loan' || withdrawalMode !== 'optimized') return;

    const btcAmount = parseFloat(btcAmountInput.value) || 0;
    const startYear = parseInt(startYearInput.value);
    const endYear = parseInt(endYearInput.value);
    const years = endYear - startYear;
    if (btcAmount <= 0) return;

    let bestMargin = 0;
    let maxExtracted = 0;
    for (let margin = 0; margin <= 100; margin += 0.5) {
      const totalExtracted = calculateTotalExtracted(btcAmount, startYear, years, margin);
      if (totalExtracted > maxExtracted) { maxExtracted = totalExtracted; bestMargin = margin; }
    }

    safetyMarginInput.value = bestMargin;
    safetyMarginValueSpan.textContent = bestMargin.toFixed(1);
    updateSimulation();
  }

  // Rows computation
  function computeLoanRows(btcAmount, startYear, simulationYears) {
    const ltvFrac = (parseInt(ltvInput.value) || 0) / 100;
    const interestRate = parseFloat(interestRateInput.value) || 0;
    const inflationRate = parseFloat(inflationRateInput.value) || 0;

    let totalDebt = 0;
    const rows = [];

    let withdrawals;
    if (withdrawalMode === 'optimized') {
      withdrawals = calculateOptimizedWithdrawals(btcAmount, startYear, simulationYears);
    } else {
      const fixedAmount = parseFloat(annualWithdrawalInput.value) || 0;
      withdrawals = Array(simulationYears + 1).fill(fixedAmount);
    }

    for (let i = 0; i <= simulationYears; i++) {
      const year = startYear + i;
      const date = new Date(year, 0, 1);
      const days = Math.floor((date - GENESIS_DATE) / 86400000);
      const supportPrice = powerLawPrice(days);

      const baseWithdrawal = withdrawals[i];
      const adjustedWithdrawal = baseWithdrawal * Math.pow(1 + (inflationRate / 100), i);
      const debtBeforeInterest = totalDebt + adjustedWithdrawal;
      const interestForYear = debtBeforeInterest * (interestRate / 100);
      totalDebt = debtBeforeInterest + interestForYear;

      const requiredBtcCollateral = (supportPrice > 0 && ltvFrac > 0) ? (totalDebt / (supportPrice * ltvFrac)) : 0;
      const maxLoanPossible = supportPrice * btcAmount * ltvFrac;

      rows.push({ i, year, supportPrice, totalDebt, interestForYear, requiredBtcCollateral, maxLoanPossible, baseWithdrawal, adjustedWithdrawal });
    }
    return rows;
  }

  function computeSellRows(btcAmount, startYear, simulationYears) {
    const inflationRate = parseFloat(inflationRateInput.value) || 0;
    const initialAnnualWithdrawal = parseFloat(annualWithdrawalInput.value) || 0;

    let remainingBtc = btcAmount;
    const rows = [];
    for (let i = 0; i <= simulationYears; i++) {
      const year = startYear + i;
      const date = new Date(year, 0, 1);
      const days = Math.floor((date - GENESIS_DATE) / 86400000);
      const supportPrice = powerLawPrice(days);
      const usdToWithdraw = initialAnnualWithdrawal * Math.pow(1 + (inflationRate / 100), i);
      const btcNeeded = supportPrice > 0 ? (usdToWithdraw / supportPrice) : Infinity;

      let btcSold = 0;
      let depleted = false;
      if (remainingBtc >= btcNeeded) { btcSold = btcNeeded; remainingBtc -= btcSold; }
      else { btcSold = remainingBtc; remainingBtc = 0; depleted = true; }

      rows.push({ i, year, supportPrice, usdToWithdraw, btcSold, remainingBtc, depleted });
    }
    return rows;
  }

  // Rendering
  function updateSimulation() {
    initializeChart();

    const btcAmount = parseFloat(btcAmountInput.value) || 0;
    const startYear = parseInt(startYearInput.value);
    const endYear = parseInt(endYearInput.value);
    const years = endYear - startYear;

    resultsTableBody.innerHTML = '';

    if (simulationMode === 'loan') renderLoan(btcAmount, startYear, years);
    else renderSell(btcAmount, startYear, years);

    updateCalculateSafeBtcButtonLabel();
    mainChart.update();
  }

  function renderLoan(btcAmount, startYear, years) {
    loanParams.classList.remove('hidden');
    targetContainer.classList.remove('hidden');  // Always show target field
    chartTitleEl.textContent = 'Debt vs. Capacity Projection';
    tableTitleEl.textContent = 'Loan Calculation Details';
    btcAmountLabel.textContent = 'BTC for Collateral';
    modeLoanBtn.classList.add('active');
    modeSellBtn.classList.remove('active');

    if (withdrawalMode === 'optimized') {
      fixedWithdrawalControls.classList.add('hidden');
      optimizedWithdrawalControls.classList.remove('hidden');
    } else {
      fixedWithdrawalControls.classList.remove('hidden');
      optimizedWithdrawalControls.classList.add('hidden');
    }

    const withdrawalHeader = withdrawalMode === 'optimized' ? 'Optimized Withdrawal ($)' : 'Annual Withdrawal ($)';

    resultsTableHeader.innerHTML = `
      <tr>
        <th class="px-6 py-3">Year</th>
        <th class="px-6 py-3">Support Price ($)</th>
        <th class="px-6 py-3">Maximum Possible Loan ($)</th>
        <th class="px-6 py-3">${withdrawalHeader}</th>
        <th class="px-6 py-3">Total Debt ($)</th>
        <th class="px-6 py-3">Annual Interest ($)</th>
        <th class="px-6 py-3">Required BTC Collateral</th>
        <th class="px-6 py-3">Unused BTC vs Peak</th>
        <th class="px-6 py-3">Additional Collateral Required (BTC)</th>
      </tr>`;

    const rows = computeLoanRows(btcAmount, startYear, years);

    let globalPeak = 0, firstPeakIndex = -1;
    rows.forEach(r => { if (r.requiredBtcCollateral > globalPeak + 1e-18) { globalPeak = r.requiredBtcCollateral; firstPeakIndex = r.i; } });
    if (firstPeakIndex === -1) firstPeakIndex = rows.length - 1;

    let progressivePeak = 0;
    let liquidationOccurred = false;
    let totalExtracted = 0;

    const labels = [], priceData = [], maxLoanData = [], totalDebtData = [];

    rows.forEach(r => {
      const { i, year, supportPrice, totalDebt, interestForYear, requiredBtcCollateral, maxLoanPossible, adjustedWithdrawal } = r;

      const isLiquidated = totalDebt > maxLoanPossible + 1e-9;
      if (isLiquidated) liquidationOccurred = true;
      
      // Only count withdrawals until liquidation occurs
      if (!liquidationOccurred) {
        totalExtracted += adjustedWithdrawal;
      }
      
      if (r.requiredBtcCollateral > progressivePeak) progressivePeak = r.requiredBtcCollateral;

      let unusedSigned;
      if (i < firstPeakIndex) {
        // Before peak: show difference between current required and global peak (negative)
        unusedSigned = r.requiredBtcCollateral - globalPeak;
      } else if (i === firstPeakIndex) {
        unusedSigned = 0;
      } else {
        unusedSigned = Math.max(0, globalPeak - r.requiredBtcCollateral);
      }

      labels.push(year);
      priceData.push(supportPrice);
      maxLoanData.push(maxLoanPossible);
      totalDebtData.push(totalDebt);

      const rowClass = liquidationOccurred ? 'row-red' : 'bg-white';
      const textColorClass = liquidationOccurred ? 'text-red-600' : 'text-slate-800';
      const colorUnused = unusedSigned < 0 ? 'text-red-600' : (unusedSigned > 0 ? 'text-emerald-700' : '');
      const ltvFrac = (parseInt(ltvInput.value) || 0) / 100 || 1;
      const addBtc = isLiquidated ? (totalDebt - maxLoanPossible) / (supportPrice * ltvFrac) : 0;

      const withdrawalClass = withdrawalMode === 'optimized' ? 'bg-blue-50' : '';

      resultsTableBody.innerHTML += `
        <tr class="${rowClass} border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium ${liquidationOccurred ? 'text-red-700' : 'text-slate-900'}">${year}</td>
          <td class="px-6 py-4">${formatCurrency(supportPrice)}</td>
          <td class="px-6 py-4">${formatCurrency(maxLoanPossible)}</td>
          <td class="px-6 py-4 ${withdrawalClass} font-medium">${formatCurrency(adjustedWithdrawal)}</td>
          <td class="px-6 py-4 font-bold ${textColorClass}">${formatCurrency(totalDebt)}</td>
          <td class="px-6 py-4">${formatCurrency(interestForYear)}</td>
          <td class="px-6 py-4">${formatBTC(r.requiredBtcCollateral)}</td>
          <td class="px-6 py-4 ${colorUnused}">${unusedSigned < 0 ? '-' : (unusedSigned > 0 ? '+' : '')}${formatBTCPlain(Math.abs(unusedSigned))} BTC</td>
          <td class="px-6 py-4 font-bold ${textColorClass}">${addBtc > 1e-18 ? formatBTC(addBtc) : 'None'}</td>
        </tr>`;
    });

    // Update target field with final year's unused vs peak value
    if (rows.length > 0 && simulationMode === 'loan') {
      const lastRow = rows[rows.length - 1];
      const finalUnused = globalPeak - lastRow.requiredBtcCollateral;
      targetUnusedVsPeakFinalInput.value = finalUnused.toFixed(8);
      
      // Make field read-only in optimized mode
      if (withdrawalMode === 'optimized') {
        targetUnusedVsPeakFinalInput.readOnly = true;
        targetUnusedVsPeakFinalInput.style.backgroundColor = '#f3f4f6';
        targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. (Read-only in Optimized mode)';
      } else {
        targetUnusedVsPeakFinalInput.readOnly = false;
        targetUnusedVsPeakFinalInput.style.backgroundColor = 'white';
        targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. Edit to require a target; BTC for Collateral = peak + target.';
      }
    }

    const strategyDescription = withdrawalMode === 'optimized' ? 'Optimized withdrawal strategy' : 'Fixed withdrawal strategy';
    tableSubtitle.innerHTML = `<strong>TOTAL EXTRACTED: ${formatCurrency(totalExtracted)}</strong> <span class="text-sm text-slate-600 font-normal ml-2">- ${strategyDescription}</span>`;
    
    // Summary row at the bottom of the table
    resultsTableBody.innerHTML += `
      <tr class="bg-blue-100 border-t-2 border-blue-300 font-semibold">
        <td class="px-6 py-4 text-blue-800" colspan="3"><strong>TOTAL EXTRACTED:</strong></td>
        <td class="px-6 py-4 text-blue-800"><strong>${formatCurrency(totalExtracted)}</strong></td>
        <td colspan="5" class="px-6 py-4 text-xs text-blue-600">${strategyDescription}</td>
      </tr>`;

    mainChart.options.scales = {
      yPrice: { type: 'logarithmic', position: 'left', title: { display: true, text: 'BTC Price ($)' }, ticks: { callback: v => formatCurrency(v) } },
      yLoan:  { type: 'logarithmic', position: 'right', title: { display: true, text: 'Loan/Debt Amount ($)' }, ticks: { callback: v => formatCurrency(v) }, grid: { drawOnChartArea: false } },
      x: { ticks: { maxRotation: 0, minRotation: 0, autoSkip: true, maxTicksLimit: 15 } }
    };
    mainChart.data = {
      labels,
      datasets: [
        { label: 'Power Law Support Price', data: rows.map(r => r.supportPrice), borderColor: '#10b981', backgroundColor: 'rgba(16,185,129,0.1)', borderWidth: 2, tension: 0.4, fill: true, pointRadius: 0, yAxisID: 'yPrice' },
        { label: 'Maximum Possible Loan',   data: rows.map(r => r.maxLoanPossible), borderColor: '#3b82f6', backgroundColor: 'transparent', borderWidth: 3, borderDash: [5,5], tension: 0.4, pointRadius: 0, yAxisID: 'yLoan' },
        { label: 'Total Accumulated Debt',  data: rows.map(r => r.totalDebt), borderColor: '#ef4444', backgroundColor: 'rgba(239,68,68,0.1)', borderWidth: 3, tension: 0.4, fill: true, pointRadius: 0, yAxisID: 'yLoan' }
      ]
    };
  }

  function renderSell(btcAmount, startYear, years) {
    loanParams.classList.add('hidden');
    targetContainer.classList.add('hidden');
    chartTitleEl.textContent = 'Remaining BTC Balance Projection';
    tableTitleEl.textContent = 'Sell Strategy Details';
    btcAmountLabel.textContent = 'BTC to Sell';
    modeLoanBtn.classList.remove('active');
    modeSellBtn.classList.add('active');

    // Ensure Annual Withdrawal visible in SELL
    fixedWithdrawalControls.classList.remove('hidden');
    optimizedWithdrawalControls.classList.add('hidden');

    resultsTableHeader.innerHTML = `
      <tr>
        <th class="px-6 py-3">Year</th>
        <th class="px-6 py-3">Support Price ($)</th>
        <th class="px-6 py-3">Annual Withdrawal ($)</th>
        <th class="px-6 py-3">BTC Sold This Year</th>
        <th class="px-6 py-3">Remaining BTC Balance</th>
      </tr>`;

    const rows = computeSellRows(btcAmount, startYear, years);

    const labels = [], balanceData = [];
    let totalWithdrawn = 0;

    rows.forEach(r => {
      const { year, supportPrice, usdToWithdraw, btcSold, remainingBtc, depleted } = r;
      labels.push(year);
      balanceData.push(remainingBtc);
      
      // Calculate actual USD withdrawn (when depleted, only count what was actually sold)
      const actualWithdrawn = btcSold * supportPrice;
      totalWithdrawn += actualWithdrawn;

      const rowClass = depleted ? 'row-red' : 'bg-white';
      const balanceCell = depleted ? 'Depleted' : formatBTC(remainingBtc);
      const balanceColor = depleted ? 'text-red-600' : 'text-slate-800';

      resultsTableBody.innerHTML += `
        <tr class="${rowClass} border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium text-slate-900">${year}</td>
          <td class="px-6 py-4">${formatCurrency(supportPrice)}</td>
          <td class="px-6 py-4">${formatCurrency(usdToWithdraw)}</td>
          <td class="px-6 py-4">${formatBTC(btcSold)}</td>
          <td class="px-6 py-4 font-bold ${balanceColor}">${balanceCell}</td>
        </tr>`;
    });

    tableSubtitle.innerHTML = `<strong>TOTAL WITHDRAWN (ACTUAL): ${formatCurrency(totalWithdrawn)}</strong>`;
    
    // Summary row at the bottom of the table
    resultsTableBody.innerHTML += `
      <tr class="bg-blue-100 border-t-2 border-blue-300 font-semibold">
        <td class="px-6 py-4 text-blue-800" colspan="2"><strong>TOTAL WITHDRAWN (ACTUAL):</strong></td>
        <td class="px-6 py-4 text-blue-800"><strong>${formatCurrency(totalWithdrawn)}</strong></td>
        <td colspan="2" class="px-6 py-4 text-xs text-blue-600">Actual amount withdrawn over the simulation period</td>
      </tr>`;

    mainChart.options.scales = {
      y: { type: 'linear', position: 'left', title: { display: true, text: 'Remaining BTC Balance' }, ticks: { callback: v => v.toFixed(2) + ' BTC' } },
      x: { ticks: { maxRotation: 0, minRotation: 0, autoSkip: true, maxTicksLimit: 15 } }
    };
    mainChart.data = {
      labels,
      datasets: [
        { label: 'Remaining BTC Balance', data: balanceData, borderColor: '#10b981', backgroundColor: 'rgba(16,185,129,0.1)', borderWidth: 3, tension: 0.4, fill: true, pointRadius: 0, yAxisID: 'y' }
      ]
    };
  }

  // Auto calculators
  function calculateSafeCollateral() {
    const startYear = parseInt(startYearInput.value);
    const endYear = parseInt(endYearInput.value);
    const years = endYear - startYear;
    const annualWithdrawal = parseFloat(annualWithdrawalInput.value) || 0;

    if (annualWithdrawal <= 0) { updateSimulation(); return; }

    let low = 0, high = 1e6, best = high;
    for (let k = 0; k < 80; k++) {
      const mid = (low + high) / 2;
      const unsafe = runLoanUnsafeCheck(mid, annualWithdrawal, startYear, years);
      if (!unsafe) { best = mid; high = mid; } else { low = mid; }
    }
    btcAmountInput.value = (Math.ceil(best * 1e8) / 1e8).toFixed(8);
    updateSimulation();
  }

  function calculateSafeCollateralOptimized() {
    const startYear = parseInt(startYearInput.value);
    const endYear = parseInt(endYearInput.value);
    const years = endYear - startYear;

    let low = 0, high = 1e6, best = high;
    for (let k = 0; k < 80; k++) {
      const mid = (low + high) / 2;
      const unsafe = runOptimizedLoanUnsafeCheck(mid, startYear, years);
      if (!unsafe) { best = mid; high = mid; } else { low = mid; }
    }
    btcAmountInput.value = (Math.ceil(best * 1e8) / 1e8).toFixed(8);
    updateSimulation();
  }

  function autoCalcBtcForSell() {
    const startYear = parseInt(startYearInput.value);
    const endYear = parseInt(endYearInput.value);
    const years = endYear - startYear;
    const annualWithdrawal = parseFloat(annualWithdrawalInput.value) || 0;

    if (annualWithdrawal <= 0) { updateSimulation(); return; }

    let low = 0, high = 1e6, best = high;
    for (let k = 0; k < 80; k++) {
      const mid = (low + high) / 2;
      const depleted = runSellDepleted(mid, annualWithdrawal, startYear, years);
      if (!depleted) { best = mid; high = mid; } else { low = mid; }
    }
    btcAmountInput.value = (Math.ceil(best * 1e8) / 1e8).toFixed(8);
    updateSimulation();
  }

  // Safe withdrawal calculator
  function calculateSafeWithdrawal() {
    const startYear = parseInt(startYearInput.value);
    const endYear = parseInt(endYearInput.value);
    const years = endYear - startYear;
    const btc = parseFloat(btcAmountInput.value) || 0;

    if (btc <= 0) return;

    let low = 0, high = 1e7, safe = 0;

    for (let i = 0; i < 80; i++) {
      const mid = (low + high) / 2;
      let unsafe;

      if (simulationMode === 'loan') {
        unsafe = runLoanUnsafeCheck(btc, mid, startYear, years);
      } else {
        unsafe = runSellDepleted(btc, mid, startYear, years);
      }

      if (!unsafe) { safe = mid; low = mid; } else { high = mid; }
    }

    annualWithdrawalInput.value = Math.floor(safe);
    updateSimulation();
  }

  // Events
  function setupEventListeners() {
    const updateSliderLabel = (input, span, isFloat = false) => {
      span.textContent = isFloat ? parseFloat(input.value).toFixed(1) : input.value;
    };

    ltvInput.addEventListener('input', () => updateSliderLabel(ltvInput, ltvValueSpan));
    interestRateInput.addEventListener('input', () => updateSliderLabel(interestRateInput, interestRateValueSpan, true));
    inflationRateInput.addEventListener('input', () => updateSliderLabel(inflationRateInput, inflationRateValueSpan, true));
    safetyMarginInput.addEventListener('input', () => updateSliderLabel(safetyMarginInput, safetyMarginValueSpan, true));

    startYearInput.addEventListener('input', () => {
      updateSliderLabel(startYearInput, startYearValueSpan);
      const minEnd = parseInt(startYearInput.value) + 1;
      endYearInput.min = String(minEnd);
      if (parseInt(endYearInput.value) < minEnd) {
        endYearInput.value = String(minEnd);
        endYearValueSpan.textContent = endYearInput.value;
      }
      updateSimulation();
    });

    endYearInput.addEventListener('input', () => {
      updateSliderLabel(endYearInput, endYearValueSpan);
      const newMaxForStart = parseInt(endYearInput.value) - 1;
      startYearInput.max = String(newMaxForStart);
      const startVal = parseInt(startYearInput.value);
      const minEnd = startVal + 1;
      if (parseInt(endYearInput.value) < minEnd) {
        endYearInput.value = String(minEnd);
        endYearValueSpan.textContent = endYearInput.value;
      }
      updateSimulation();
    });

    [btcAmountInput, ltvInput, interestRateInput, inflationRateInput, annualWithdrawalInput, safetyMarginInput, minWithdrawalInput]
      .forEach(input => input.addEventListener('change', updateSimulation));

    // Strategy mode switch
    modeLoanBtn.addEventListener('click', () => {
      simulationMode = 'loan';
      // Always reset to Fixed when returning to LOAN mode.
      withdrawalMode = 'fixed';
      modeFixedWithdrawalBtn.classList.add('active');
      modeOptimizedWithdrawalBtn.classList.remove('active');
      
      modeLoanBtn.classList.add('active'); 
      modeSellBtn.classList.remove('active');
      
      // Reset target field to editable
      targetUnusedVsPeakFinalInput.readOnly = false;
      targetUnusedVsPeakFinalInput.style.backgroundColor = 'white';
      targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. Edit to require a target; BTC for Collateral = peak + target.';
      
      calculateSafeCollateral();
    });

    modeSellBtn.addEventListener('click', () => {
      simulationMode = 'sell';
      modeSellBtn.classList.add('active'); 
      modeLoanBtn.classList.remove('active');
      autoCalcBtcForSell();
    });

    // Withdrawal mode switch
    modeFixedWithdrawalBtn.addEventListener('click', () => {
      withdrawalMode = 'fixed';
      modeFixedWithdrawalBtn.classList.add('active'); 
      modeOptimizedWithdrawalBtn.classList.remove('active');
      targetUnusedVsPeakFinalInput.readOnly = false;
      targetUnusedVsPeakFinalInput.style.backgroundColor = 'white';
      targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. Edit to require a target; BTC for Collateral = peak + target.';
      updateSimulation();
    });

    modeOptimizedWithdrawalBtn.addEventListener('click', () => {
      withdrawalMode = 'optimized';
      modeOptimizedWithdrawalBtn.classList.add('active'); 
      modeFixedWithdrawalBtn.classList.remove('active');
      targetUnusedVsPeakFinalInput.readOnly = true;
      targetUnusedVsPeakFinalInput.style.backgroundColor = '#f3f4f6';
      targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. (Read-only in Optimized mode)';
      updateSimulation();
    });

    // Maximize Safety Margin button
    maximizeSafetyMarginBtn.addEventListener('click', maximizeSafetyMargin);

    // Calculate Safe Amount
    document.getElementById('calculateSafeWithdrawalBtn').addEventListener('click', calculateSafeWithdrawal);

    // Calculate Safe BTC works across modes
    document.getElementById('calculateSafeCollateralBtn').addEventListener('click', () => {
      if (simulationMode === 'loan') {
        if (withdrawalMode === 'fixed') calculateSafeCollateral();
        else calculateSafeCollateralOptimized();
      } else {
        autoCalcBtcForSell();
      }
    });

    // Click on label for SELL to auto-calc minimal BTC
    btcAmountLabel.addEventListener('click', () => {
      if (simulationMode === 'sell') autoCalcBtcForSell();
    });

    // Target editor (only LOAN in fixed mode)
    let applyTimeout;
    targetUnusedVsPeakFinalInput.addEventListener('input', () => {
      if (simulationMode !== 'loan' || withdrawalMode !== 'fixed') return;
      const target = parseFloat(targetUnusedVsPeakFinalInput.value);
      if (!isFinite(target)) return;

      const startYear = parseInt(startYearInput.value);
      const endYear = parseInt(endYearInput.value);
      const years = endYear - startYear;

      const rows = computeLoanRows(parseFloat(btcAmountInput.value) || 0, startYear, years);
      const peak = rows.reduce((m, r) => Math.max(m, r.requiredBtcCollateral), 0);

      const desiredBtc = Math.max(0, peak + target);
      const currentBtc = parseFloat(btcAmountInput.value) || 0;
      if (Math.abs(desiredBtc - currentBtc) > 1e-9) {
        if (applyTimeout) clearTimeout(applyTimeout);
        applyTimeout = setTimeout(() => {
          btcAmountInput.value = (Math.round(desiredBtc * 1e8) / 1e8).toFixed(8);
          updateSimulation();
        }, 30);
      }
    });
  }

  // Init
  window.onload = () => {
    const currentYear = new Date().getFullYear();
    startYearInput.min = currentYear;
    startYearInput.value = currentYear;
    endYearInput.min = currentYear + 1;
    endYearInput.max = 2085;
    endYearInput.value = 2085;
    startYearInput.max = endYearInput.value - 1;

    startYearValueSpan.textContent = startYearInput.value;
    endYearValueSpan.textContent = endYearInput.value;
    ltvValueSpan.textContent = ltvInput.value;
    interestRateValueSpan.textContent = parseFloat(interestRateInput.value).toFixed(1);
    inflationRateValueSpan.textContent = parseFloat(inflationRateInput.value).toFixed(1);
    safetyMarginValueSpan.textContent = parseFloat(safetyMarginInput.value).toFixed(1);

    setupEventListeners();
    initializeChart();

    // Default: LOAN with fixed withdrawal and automatic safe collateral
    calculateSafeCollateral();
  };
</script>
</body>
</html>


