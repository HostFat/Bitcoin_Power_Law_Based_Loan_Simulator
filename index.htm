<!DOCTYPE html>
<html lang="en" data-zktls-injected="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Financial Strategy Simulator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com/">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; }
    .chart-container { position: relative; width: 100%; height: 40vh; max-height: 500px; }
    @media (min-width: 768px) { .chart-container { height: 60vh; } }
    input[type="range"] { width: 100%; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #3b82f6; cursor: pointer; border-radius: 50%; }
    input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; background: #3b82f6; cursor: pointer; border-radius: 50%; }
    .mode-button { padding: 0.5rem 1rem; border: 1px solid #cbd5e1; color: #64748b; cursor: pointer; transition: all 0.2s; }
    .mode-button.active { background-color: #3b82f6; color: white; border-color: #3b82f6; font-weight: 600; }
    .number-input { width: 100%; }
    .row-red { background-color: #fee2e2; }
    .hidden { display: none; }
    #powerLawInfoBox a { color: #1d4ed8; text-decoration: underline; }
    #powerLawInfoBox ul { list-style: disc; padding-left: 1.25rem; }
  
/* Hide number input spinners for the targetUnusedVsPeakFinal field */
#targetUnusedVsPeakFinal::-webkit-outer-spin-button,
#targetUnusedVsPeakFinal::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
#targetUnusedVsPeakFinal { -moz-appearance: textfield; }


/* Extra lock styling for the Unused BTC target field */
#targetUnusedVsPeakFinal { caret-color: transparent; }
#targetUnusedVsPeakFinal:disabled { cursor: default; }

</style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.container{width:100%}@media (min-width: 640px){.container{max-width:640px}}@media (min-width: 768px){.container{max-width:768px}}@media (min-width: 1024px){.container{max-width:1024px}}@media (min-width: 1280px){.container{max-width:1280px}}@media (min-width: 1536px){.container{max-width:1536px}}.mx-auto{margin-left:auto;margin-right:auto}.-ml-px{margin-left:-1px}.mb-2{margin-bottom:0.5rem}.mb-3{margin-bottom:0.75rem}.mb-4{margin-bottom:1rem}.mb-8{margin-bottom:2rem}.mr-3{margin-right:0.75rem}.mt-1{margin-top:0.25rem}.mt-12{margin-top:3rem}.mt-2{margin-top:0.5rem}.mt-8{margin-top:2rem}.ml-2{margin-left:0.5rem}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.h-2{height:0.5rem}.w-full{width:100%}.cursor-pointer{cursor:pointer}.appearance-none{-webkit-appearance:none;appearance:none}.grid-cols-1{grid-template-columns:repeat(1, minmax(0, 1fr))}.flex-col{flex-direction:column}.items-center{align-items:center}.items-baseline{align-items:baseline}.justify-between{justify-content:space-between}.gap-8{gap:2rem}.space-x-2 > :not([hidden]) ~ :not([hidden]){--tw-space-x-reverse:0;margin-right:calc(0.5rem * var(--tw-space-x-reverse));margin-left:calc(0.5rem * calc(1 - var(--tw-space-x-reverse)))}.space-y-3 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(0.75rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(0.75rem * var(--tw-space-y-reverse))}.space-y-4 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(1rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1rem * var(--tw-space-y-reverse))}.space-y-6 > :not([hidden]) ~ :not([hidden]){--tw-space-y-reverse:0;margin-top:calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));margin-bottom:calc(1.5rem * var(--tw-space-y-reverse))}.overflow-hidden{overflow:hidden}.overflow-x-auto{overflow-x:auto}.whitespace-nowrap{white-space:nowrap}.rounded-lg{border-radius:0.5rem}.rounded-md{border-radius:0.375rem}.rounded-xl{border-radius:0.75rem}.rounded-l-md{border-top-left-radius:0.375rem;border-bottom-left-radius:0.375rem}.rounded-r-md{border-top-right-radius:0.375rem;border-bottom-right-radius:0.375rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-t-2{border-top-width:2px}.border-rose-200{--tw-border-opacity:1;border-color:rgb(254 205 211 / var(--tw-border-opacity, 1))}.border-slate-300{--tw-border-opacity:1;border-color:rgb(203 213 225 / var(--tw-border-opacity, 1))}.border-stone-200{--tw-border-opacity:1;border-color:rgb(231 229 228 / var(--tw-border-opacity, 1))}.border-blue-300{--tw-border-opacity:1;border-color:rgb(147 197 253 / var(--tw-border-opacity, 1))}.bg-stone-50{--tw-bg-opacity:1;background-color:rgb(250 250 249 / var(--tw-bg-opacity, 1))}.bg-amber-600{--tw-bg-opacity:1;background-color:rgb(217 119 6 / var(--tw-bg-opacity, 1))}.bg-blue-500{--tw-bg-opacity:1;background-color:rgb(59 130 246 / var(--tw-bg-opacity, 1))}.bg-rose-50{--tw-bg-opacity:1;background-color:rgb(255 241 242 / var(--tw-bg-opacity, 1))}.bg-stone-100{--tw-bg-opacity:1;background-color:rgb(245 245 244 / var(--tw-bg-opacity, 1))}.bg-stone-200{--tw-bg-opacity:1;background-color:rgb(231 229 228 / var(--tw-bg-opacity, 1))}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))}.bg-blue-100{--tw-bg-opacity:1;background-color:rgb(219 234 254 / var(--tw-bg-opacity, 1))}.p-4{padding:1rem}.p-6{padding:1.5rem}.px-3{padding-left:0.75rem;padding-right:0.75rem}.py-2{padding-top:0.5rem;padding-bottom:0.5rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.py-3{padding-top:0.75rem;padding-bottom:0.75rem}.py-4{padding-top:1rem;padding-bottom:1rem}.text-left{text-align:left}.text-center{text-align:center}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-base{font-size:1rem;line-height:1.5rem}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.text-xs{font-size:0.75rem;line-height:1rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-semibold{font-weight:600}.font-normal{font-weight:400}.uppercase{text-transform:uppercase}.text-slate-800{--tw-text-opacity:1;color:rgb(30 41 59 / var(--tw-text-opacity, 1))}.text-blue-700{--tw-text-opacity:1;color:rgb(29 78 216 / var(--tw-text-opacity, 1))}.text-blue-800{--tw-text-opacity:1;color:rgb(30 64 175 / var(--tw-text-opacity, 1))}.text-rose-700{--tw-text-opacity:1;color:rgb(190 18 60 / var(--tw-text-opacity, 1))}.text-rose-800{--tw-text-opacity:1;color:rgb(159 18 57 / var(--tw-text-opacity, 1))}.text-slate-500{--tw-text-opacity:1;color:rgb(100 116 139 / var(--tw-text-opacity, 1))}.text-slate-600{--tw-text-opacity:1;color:rgb(71 85 105 / var(--tw-text-opacity, 1))}.text-slate-700{--tw-text-opacity:1;color:rgb(51 65 85 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.text-blue-600{--tw-text-opacity:1;color:rgb(37 99 235 / var(--tw-text-opacity, 1))}.text-emerald-700{--tw-text-opacity:1;color:rgb(4 120 87 / var(--tw-text-opacity, 1))}.text-red-600{--tw-text-opacity:1;color:rgb(220 38 38 / var(--tw-text-opacity, 1))}.text-slate-900{--tw-text-opacity:1;color:rgb(15 23 42 / var(--tw-text-opacity, 1))}.placeholder-slate-400::placeholder{--tw-placeholder-opacity:1;color:rgb(148 163 184 / var(--tw-placeholder-opacity, 1))}.accent-blue-500{accent-color:#3b82f6}.opacity-80{opacity:0.8}.shadow-lg{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.hover\:bg-amber-700:hover{--tw-bg-opacity:1;background-color:rgb(180 83 9 / var(--tw-bg-opacity, 1))}.hover\:bg-blue-600:hover{--tw-bg-opacity:1;background-color:rgb(37 99 235 / var(--tw-bg-opacity, 1))}.hover\:bg-stone-50:hover{--tw-bg-opacity:1;background-color:rgb(250 250 249 / var(--tw-bg-opacity, 1))}.focus\:border-teal-500:focus{--tw-border-opacity:1;border-color:rgb(20 184 166 / var(--tw-border-opacity, 1))}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\:ring-1:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.focus\:ring-amber-500:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(245 158 11 / var(--tw-ring-opacity, 1))}.focus\:ring-blue-500:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(59 130 246 / var(--tw-ring-opacity, 1))}.focus\:ring-teal-500:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(20 184 166 / var(--tw-ring-opacity, 1))}.focus\:ring-offset-2:focus{--tw-ring-offset-width:2px}@media (min-width: 640px){.sm\:p-6{padding:1.5rem}}@media (min-width: 768px){.md\:text-4xl{font-size:2.25rem;line-height:2.5rem}}@media (min-width: 1024px){.lg\:col-span-1{grid-column:span 1 / span 1}.lg\:col-span-2{grid-column:span 2 / span 2}.lg\:grid-cols-3{grid-template-columns:repeat(3, minmax(0, 1fr))}.lg\:p-8{padding:2rem}}
/* Extra lock styling for the Unused BTC target field */
#targetUnusedVsPeakFinal { caret-color: transparent; }
#targetUnusedVsPeakFinal:disabled { cursor: default; }

</style></head>

<body class="bg-stone-50 text-slate-800">

  <div class="container mx-auto p-4 sm:p-6 lg:p-8">
    <header class="mb-8">
      <div class="text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-blue-800">Bitcoin Power Law Based Simulator</h1>
        <p class="mt-2 text-slate-600">An interactive tool to explore financial strategies based on a long-term Bitcoin growth model.</p>
      </div>
    </header>

    <section class="mb-8">
      <div id="powerLawInfoBox" class="bg-white p-6 rounded-xl shadow-md border border-stone-200">
        <h3 class="text-xl font-semibold mb-3 text-slate-700">What is the Power Law Support Line?</h3>
        <div id="powerLawInfoContent" class="text-sm text-slate-600 space-y-3">
          <p>The 'Power Law Support Line' is a mathematical model that plots a historical support level for Bitcoin's price over time. This simulator uses this formula to project a future support value for BTC.</p>
          <p><strong>Formula:</strong> <code>Support Price = (1.0117e-17 × days_since_genesis^5.82) × 0.42</code></p>
          <div>
            <strong>Sources:</strong>
            <ul>
              <li><a href="https://giovannisantostasi.medium.com/the-bitcoin-power-law-theory-962dfaf99ee9" target="_blank" rel="noopener noreferrer">The Bitcoin Power Law Theory (Giovanni Santostasi)</a></li>
              <li><a href="https://charts.bitbo.io/long-term-power-law/" target="_blank" rel="noopener noreferrer">Bitbo: Long-term Power Law chart</a></li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <aside class="lg:col-span-1 flex flex-col gap-8">
        <div class="bg-white p-6 rounded-xl shadow-md border border-stone-200">
          <h2 class="text-2xl font-semibold mb-4 text-slate-700">Simulation Parameters</h2>

          <div class="space-y-6">
            <div>
              <label class="block font-medium text-slate-600 mb-2">Strategy</label>
              <div class="flex items-center">
                <div class="flex rounded-md shadow-sm">
                  <button type="button" id="modeLoan" class="mode-button rounded-l-md active">Loan</button>
                  <button type="button" id="modeSell" class="mode-button rounded-r-md -ml-px">Sell</button>
                </div>
                <div style="margin-left: 1cm;">
                  <button type="button" id="exampleBtn" class="w-[300px] py-2 bg-blue-500 text-white rounded-md shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 font-bold mode-button">
                    Example
                  </button>
                </div>
              </div>
            </div>

            <div>
              <label id="btcAmountLabel" for="btcAmount" class="block font-medium text-slate-600 cursor-pointer">BTC for Collateral</label>
              <div class="flex items-center space-x-2 mt-1">
                <input type="number" id="btcAmount" value="0" step="0.00000001" min="0" max="1000000" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500">
                <button type="button" id="calculateSafeWithdrawalBtn" class="px-3 py-2 bg-blue-500 text-white rounded-md shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 text-sm whitespace-nowrap">Calculate Safe Withdrawal</button>
              </div>
            </div>

            <!-- Annual Inflation Rate shown always right after BTC -->
            <div>
              <label for="inflationRate" class="block font-medium text-slate-600">
                Annual Inflation Rate: <span id="inflationRateValue" class="font-bold text-blue-700">0.0</span>%
              </label>
              <input type="range" id="inflationRate" min="0" max="20" step="0.1" value="0" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
            </div>

            <!-- Tax controls (only visible in sell mode) -->
            <div id="taxControls" class="hidden space-y-6">
              <div>
                <label for="taxRate" class="block font-medium text-slate-600">
                  Tax Rate: <span id="taxRateValue" class="font-bold text-blue-700">0</span>%
                </label>
                <input type="range" id="taxRate" min="0" max="100" step="1" value="0" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                
                <!-- Tax Rate Warning Message -->
                <div id="taxRateWarning" class="hidden mt-2">
                  <p class="text-red-600 font-bold text-sm break-all">
                    Remember that paying taxes makes you a slave and a stupid.  You are killing yourself, your family and you are financing death of many other people and children. So you are even evil by knowing this.
                  </p>
                </div>
              </div>

              <div>
                <label for="purchasePrice" class="block font-medium text-slate-600">Purchase Price ($)</label>
                <input type="number" id="purchasePrice" value="0" step="100" min="0" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500 mt-1">
              </div>

              <div>
                <label for="carryoverPeriod" class="block font-medium text-slate-600">Capital Loss Carryover Period</label>
                <input type="number" id="carryoverPeriod" value="0" step="1" min="0" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500 mt-1">
                <p class="text-xs text-slate-500 mt-1">0 is equal unlimited</p>
              </div>

              <!-- Remaining Amount controls (only visible in sell mode) -->
              <div>
                <label for="remainingAmount" class="block font-medium text-slate-600">Remaining Amount</label>
                <div class="flex items-center space-x-2 mt-1">
                  <input type="number" id="remainingAmount" value="0" step="0.00000001" min="0" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500">
                  <div class="flex rounded-md shadow-sm">
                    <button type="button" id="remainingAmountBTC" class="mode-button rounded-l-md active">BTC</button>
                    <button type="button" id="remainingAmountUSD" class="mode-button rounded-r-md -ml-px">USD</button>
                  </div>
                </div>
              </div>
            </div>

            <div id="loanParams">
              <div class="space-y-6">
                <div>
                  <label for="ltv" class="block font-medium text-slate-600">
                    Loan-to-Value (LTV): <span id="ltvValue" class="font-bold text-blue-700">0</span>%
                  </label>
                  <input type="range" id="ltv" min="0" max="100" step="1" value="0" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>
                <div>
                  <label for="interestRate" class="block font-medium text-slate-600">
                    Annual Interest Rate: <span id="interestRateValue" class="font-bold text-blue-700">0.0</span>%
                  </label>
                  <input type="range" id="interestRate" min="0" max="20" step="0.1" value="0" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>

                <!-- Withdrawal Strategy Toggle -->
                <div>
                  <label class="block font-medium text-slate-600 mb-2">Withdrawal Strategy</label>
                  <div class="flex rounded-md shadow-sm">
                    <button type="button" id="modeFixedWithdrawal" class="mode-button rounded-l-md active">Fixed</button>
                    <button type="button" id="modeOptimizedWithdrawal" class="mode-button rounded-r-md -ml-px">Optimized</button>
                  </div>
                </div>

              </div>
            </div>

            <!-- Fixed Withdrawal Controls -->
            <div id="fixedWithdrawalControls">
              <label for="annualWithdrawal" class="block font-medium text-slate-600">Annual Withdrawal ($)</label>
              <div class="flex items-center space-x-2 mt-1">
                <input type="number" id="annualWithdrawal" value="0" step="100" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500">
                <button type="button" id="calculateSafeCollateralBtn" class="px-3 py-2 bg-blue-500 text-white rounded-md shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 text-sm whitespace-nowrap">Calculate Safe Collateral</button>
              </div>
            </div>

            <!-- Optimized Withdrawal Controls -->
            <div id="optimizedWithdrawalControls" class="hidden">
              <div class="space-y-4">
                <div>
                  <label for="safetyMargin" class="block font-medium text-slate-600">
                    Safety Margin: <span id="safetyMarginValue" class="font-bold text-blue-700">5.0</span>%
                  </label>
                  <div class="flex items-center space-x-2 mt-1">
                    <input type="range" id="safetyMargin" min="0" max="100" step="0.5" value="5" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                    <button type="button" id="maximizeSafetyMarginBtn" class="px-3 py-2 bg-amber-600 text-white rounded-md shadow-sm hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 text-sm whitespace-nowrap text-center">
                      <div class="font-medium">Maximize</div>
                      <div class="text-xs opacity-80">Wait a little</div>
                    </button>
                  </div>
                  <p class="text-xs text-slate-500 mt-1">Reduces max withdrawal capacity by this percentage to avoid liquidation risk. 5% = use only 95% of available capacity.</p>
                </div>

                <div>
                  <label for="minWithdrawal" class="block font-medium text-slate-600">Minimum Withdrawal ($)</label>
                  <input type="number" id="minWithdrawal" value="0" step="100" min="0" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500 mt-1">
                  <p class="text-xs text-slate-500 mt-1">Minimum annual withdrawal amount. Optimized withdrawals will never go below this value.</p>
                </div>
              </div>
            </div>

            <div>
              <label for="startYear" class="block font-medium text-slate-600">
                Simulate From Year: <span id="startYearValue" class="font-bold text-blue-700">2009</span>
              </label>
              <input type="range" id="startYear" min="2009" max="2084" step="1" value="2009" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
            </div>

            <div>
              <label for="endYear" class="block font-medium text-slate-600">
                Simulate Until Year: <span id="endYearValue" class="font-bold text-blue-700">2025</span>
              </label>
              <input type="range" id="endYear" min="2010" max="2085" step="1" value="2025" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
            </div>

            <div id="targetContainer" class="mt-2">
              <label for="targetUnusedVsPeakFinal" class="block font-medium text-slate-600">Unused BTC vs Peak at final year</label>
              <input type="number" id="targetUnusedVsPeakFinal" value="0.00000000" step="0.00000001" min="-1000000" class="number-input block w-full px-3 py-2 bg-white border border-slate-300 rounded-md text-sm shadow-sm placeholder-slate-400 focus:outline-none focus:border-teal-500 focus:ring-1 focus:ring-teal-500" style="background-color: white;">
              <p id="targetDescription" class="text-xs text-slate-500 mt-1">Shows BTC not used as collateral in the final year. Maybe it can go to the children :)</p>
            </div>

          </div>
        </div>
      </aside>

      <section class="lg:col-span-2 flex flex-col gap-8">
        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg border border-stone-200">
          <h2 id="chartTitle" class="text-2xl font-semibold mb-4 text-center text-slate-700">Debt vs. Capacity Projection</h2>
          <div class="chart-container"><canvas id="mainChart" style="box-sizing: border-box; display: block; height: 500px; width: 920px;" width="920" height="500"></canvas></div>
        </div>
      </section>
    </main>

    <section class="mt-8">
      <div class="bg-white rounded-xl shadow-lg border border-stone-200 overflow-hidden">
        <div class="flex justify-between items-baseline p-6 border-b">
          <h2 id="tableTitle" class="text-2xl font-semibold text-slate-700">Loan Calculation Details</h2>
          <p id="tableSubtitle" class="text-base font-medium text-blue-800 whitespace-nowrap"><strong>TOTAL EXTRACTED: $8,714,668.10</strong> <span class="text-sm text-slate-600 font-normal ml-2">- Fixed withdrawal strategy</span></p>
        </div>
        <div class="overflow-x-auto">
          <table class="w-full text-sm text-left text-slate-500">
            <thead id="resultsTableHeader" class="text-xs text-slate-700 uppercase bg-stone-100">
      <tr>
        <th class="px-6 py-3">Year</th>
        <th class="px-6 py-3">Support Price ($)</th>
        <th class="px-6 py-3">Maximum Possible Loan ($)</th>
        <th class="px-6 py-3">Annual Withdrawal ($)</th>
        <th class="px-6 py-3">Total Debt ($)</th>
        <th class="px-6 py-3">Annual Interest ($)</th>
        <th class="px-6 py-3">Required BTC Collateral</th>
        <th class="px-6 py-3">Unused BTC vs Peak</th>
        <th class="px-6 py-3">Additional Collateral Required (BTC)</th>
      </tr></thead>
            <tbody id="resultsTableBody">
        <tr class="bg-white border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium text-slate-900">2025</td>
          <td class="px-6 py-4">$35,420.65</td>
          <td class="px-6 py-4">$19,288.38</td>
          <td class="px-6 py-4  font-medium">$10,000.00</td>
          <td class="px-6 py-4 font-bold text-slate-800">$10,700.00</td>
          <td class="px-6 py-4">$700.00</td>
          <td class="px-6 py-4">0.43154805 BTC</td>
          <td class="px-6 py-4 text-red-600">-0.34638308 BTC</td>
          <td class="px-6 py-4 font-bold text-slate-800">None</td>
        </tr>
      
        <tr class="bg-white border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium text-slate-900">2026</td>
          <td class="px-6 py-4">$50,404.06</td>
          <td class="px-6 py-4">$27,447.62</td>
          <td class="px-6 py-4  font-medium">$10,700.00</td>
          <td class="px-6 py-4 font-bold text-slate-800">$22,898.00</td>
          <td class="px-6 py-4">$1,498.00</td>
          <td class="px-6 py-4">0.64898396 BTC</td>
          <td class="px-6 py-4 text-red-600">-0.12894717 BTC</td>
          <td class="px-6 py-4 font-bold text-slate-800">None</td>
        </tr>
      
        <tr class="bg-white border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium text-slate-900">2027</td>
          <td class="px-6 py-4">$70,293.66</td>
          <td class="px-6 py-4">$38,278.54</td>
          <td class="px-6 py-4  font-medium">$11,449.00</td>
          <td class="px-6 py-4 font-bold text-slate-800">$36,751.29</td>
          <td class="px-6 py-4">$2,404.29</td>
          <td class="px-6 py-4">0.74689296 BTC</td>
          <td class="px-6 py-4 text-red-600">-0.03103816 BTC</td>
          <td class="px-6 py-4 font-bold text-slate-800">None</td>
        </tr>
      
        <tr class="bg-white border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium text-slate-900">2028</td>
          <td class="px-6 py-4">$96,284.40</td>
          <td class="px-6 py-4">$52,431.84</td>
          <td class="px-6 py-4  font-medium">$12,250.43</td>
          <td class="px-6 py-4 font-bold text-slate-800">$52,431.84</td>
          <td class="px-6 py-4">$3,430.12</td>
          <td class="px-6 py-4">0.77793113 BTC</td>
          <td class="px-6 py-4 ">0.00000000 BTC</td>
          <td class="px-6 py-4 font-bold text-slate-800">None</td>
        </tr>
      
        <tr class="bg-white border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium text-slate-900">2029</td>
          <td class="px-6 py-4">$129,877.07</td>
          <td class="px-6 py-4">$70,724.79</td>
          <td class="px-6 py-4  font-medium">$13,107.96</td>
          <td class="px-6 py-4 font-bold text-slate-800">$70,127.59</td>
          <td class="px-6 py-4">$4,587.79</td>
          <td class="px-6 py-4">0.77136223 BTC</td>
          <td class="px-6 py-4 text-emerald-700">+0.00656890 BTC</td>
          <td class="px-6 py-4 font-bold text-slate-800">None</td>
        </tr>
      
        <tr class="bg-blue-100 border-t-2 border-blue-300 font-semibold">
        <td class="px-6 py-4 text-blue-800" colspan="3"><strong>TOTAL EXTRACTED:</strong></td>
        <td class="px-6 py-4 text-blue-800"><strong>$8,714,668.10</strong></td>
        <td colspan="5" class="px-6 py-4 text-xs text-blue-600">Fixed withdrawal strategy</td>
      </tr>
    </tbody>
          </table>
        </div>
      </div>
    </section>

    <footer class="mt-12 bg-rose-50 border border-rose-200 text-rose-800 p-6 rounded-xl shadow-md">
      <h2 class="text-2xl font-bold mb-3 flex items-center"><span class="text-3xl mr-3">⚠️</span><span>Fundamental Warnings and Risks</span></h2>
      <div class="space-y-3 text-rose-700">
        <p><strong>This tool is a purely educational simulation and does NOT constitute financial advice.</strong></p>
        <p><strong>Liquidation Risk:</strong> If the market price of Bitcoin drops, your real LTV will increase. The lender may liquidate (sell) your collateral to repay the loan, causing the permanent loss of your Bitcoin.</p>
        <p><strong>Extreme Volatility:</strong> The Power Law model is a long-term trend and ignores short- and medium-term volatility. The actual price can deviate significantly from the forecast.</p>
        <p><strong>Model Reliability:</strong> There is no guarantee that Bitcoin's price will continue to follow this model in the future.</p>
      </div>
    </footer>
  </div>

<script>
(function() {
  'use strict';

  // Constants
  const GENESIS_DATE = new Date('2009-01-03');
  const EPS = 1e-9;
  const BINARY_SEARCH_ITERATIONS = 50; // Reduced from 80 for sufficient precision
  const BINARY_SEARCH_PRECISION = 1e-6;

  // Historical Bitcoin Prices (Monthly closing prices from provided data)
  const HISTORICAL_BITCOIN_PRICES = [
    // 2010
    { year: 2010, month: 7, price: 0.0627 },
    { year: 2010, month: 8, price: 0.06 },
    { year: 2010, month: 9, price: 0.0619 },
    { year: 2010, month: 10, price: 0.19 },
    { year: 2010, month: 11, price: 0.2082 },
    { year: 2010, month: 12, price: 0.3 },
    
    // 2011
    { year: 2011, month: 1, price: 0.52 },
    { year: 2011, month: 2, price: 0.86 },
    { year: 2011, month: 3, price: 0.7846 },
    { year: 2011, month: 4, price: 2.88 },
    { year: 2011, month: 5, price: 8.741 },
    { year: 2011, month: 6, price: 16.101 },
    { year: 2011, month: 7, price: 13.498 },
    { year: 2011, month: 8, price: 8.1995 },
    { year: 2011, month: 9, price: 5.1401 },
    { year: 2011, month: 10, price: 3.248 },
    { year: 2011, month: 11, price: 2.9701 },
    { year: 2011, month: 12, price: 4.248 },
    
    // 2012
    { year: 2012, month: 1, price: 5.4838 },
    { year: 2012, month: 2, price: 4.86 },
    { year: 2012, month: 3, price: 4.86 },
    { year: 2012, month: 4, price: 4.9491 },
    { year: 2012, month: 5, price: 5.1801 },
    { year: 2012, month: 6, price: 6.65 },
    { year: 2012, month: 7, price: 9.35 },
    { year: 2012, month: 8, price: 10.16 },
    { year: 2012, month: 9, price: 12.391 },
    { year: 2012, month: 10, price: 11.201 },
    { year: 2012, month: 11, price: 12.565 },
    { year: 2012, month: 12, price: 13.51 },
    
    // 2013
    { year: 2013, month: 1, price: 20.41 },
    { year: 2013, month: 2, price: 33.38 },
    { year: 2013, month: 3, price: 90.5 },
    { year: 2013, month: 4, price: 138.38 },
    { year: 2013, month: 5, price: 127.4 },
    { year: 2013, month: 6, price: 95.399 },
    { year: 2013, month: 7, price: 107.75 },
    { year: 2013, month: 8, price: 136.01 },
    { year: 2013, month: 9, price: 141.32 },
    { year: 2013, month: 10, price: 211.37 },
    { year: 2013, month: 11, price: 1157.94 },
    { year: 2013, month: 12, price: 753.52 },
    
    // 2014
    { year: 2014, month: 1, price: 822.57 },
    { year: 2014, month: 2, price: 560.95 },
    { year: 2014, month: 3, price: 453.37 },
    { year: 2014, month: 4, price: 445.87 },
    { year: 2014, month: 5, price: 608.79 },
    { year: 2014, month: 6, price: 636.86 },
    { year: 2014, month: 7, price: 584.22 },
    { year: 2014, month: 8, price: 508.7 },
    { year: 2014, month: 9, price: 386.01 },
    { year: 2014, month: 10, price: 340.06 },
    { year: 2014, month: 11, price: 378.57 },
    { year: 2014, month: 12, price: 316.89 },
    
    // 2015
    { year: 2015, month: 1, price: 229.65 },
    { year: 2015, month: 2, price: 254.38 },
    { year: 2015, month: 3, price: 245.014 },
    { year: 2015, month: 4, price: 236.66 },
    { year: 2015, month: 5, price: 237.2 },
    { year: 2015, month: 6, price: 263.054 },
    { year: 2015, month: 7, price: 285.19 },
    { year: 2015, month: 8, price: 229.84 },
    { year: 2015, month: 9, price: 236.647 },
    { year: 2015, month: 10, price: 319.826 },
    { year: 2015, month: 11, price: 378.243 },
    { year: 2015, month: 12, price: 430.496 },
    
    // 2016
    { year: 2016, month: 1, price: 375.235 },
    { year: 2016, month: 2, price: 437.197 },
    { year: 2016, month: 3, price: 416.095 },
    { year: 2016, month: 4, price: 455.726 },
    { year: 2016, month: 5, price: 527.232 },
    { year: 2016, month: 6, price: 667.78 },
    { year: 2016, month: 7, price: 657.333 },
    { year: 2016, month: 8, price: 572.344 },
    { year: 2016, month: 9, price: 605.62 },
    { year: 2016, month: 10, price: 699.105 },
    { year: 2016, month: 11, price: 741.84 },
    { year: 2016, month: 12, price: 960.523 },
    
    // 2017
    { year: 2017, month: 1, price: 966.931 },
    { year: 2017, month: 2, price: 1192.75 },
    { year: 2017, month: 3, price: 1076.89 },
    { year: 2017, month: 4, price: 1295 },
    { year: 2017, month: 5, price: 2307.34 },
    { year: 2017, month: 6, price: 2545.82 },
    { year: 2017, month: 7, price: 2872.74 },
    { year: 2017, month: 8, price: 4766.44 },
    { year: 2017, month: 9, price: 4166.67 },
    { year: 2017, month: 10, price: 6385.7 },
    { year: 2017, month: 11, price: 9803.92 },
    { year: 2017, month: 12, price: 14368 },
    
    // 2018
    { year: 2018, month: 1, price: 10081 },
    { year: 2018, month: 2, price: 10428 },
    { year: 2018, month: 3, price: 6816.63 },
    { year: 2018, month: 4, price: 9216.59 },
    { year: 2018, month: 5, price: 7547.17 },
    { year: 2018, month: 6, price: 5882.35 },
    { year: 2018, month: 7, price: 7710.1 },
    { year: 2018, month: 8, price: 7042.25 },
    { year: 2018, month: 9, price: 6675.57 },
    { year: 2018, month: 10, price: 6325.11 },
    { year: 2018, month: 11, price: 3974.56 },
    { year: 2018, month: 12, price: 3728.56 },
    
    // 2019
    { year: 2019, month: 1, price: 3450.66 },
    { year: 2019, month: 2, price: 3829.95 },
    { year: 2019, month: 3, price: 4101.72 },
    { year: 2019, month: 4, price: 5370.57 },
    { year: 2019, month: 5, price: 8431.7 },
    { year: 2019, month: 6, price: 12315 },
    { year: 2019, month: 7, price: 10050 },
    { year: 2019, month: 8, price: 9578.54 },
    { year: 2019, month: 9, price: 8271.3 },
    { year: 2019, month: 10, price: 9132.42 },
    { year: 2019, month: 11, price: 7757.95 },
    { year: 2019, month: 12, price: 7194.24 },
    
    // 2020
    { year: 2020, month: 1, price: 9310.99 },
    { year: 2020, month: 2, price: 8620.69 },
    { year: 2020, month: 3, price: 6459.95 },
    { year: 2020, month: 4, price: 8764.24 },
    { year: 2020, month: 5, price: 9398.5 },
    { year: 2020, month: 6, price: 9165.9 },
    { year: 2020, month: 7, price: 11328 },
    { year: 2020, month: 8, price: 11640 },
    { year: 2020, month: 9, price: 10709 },
    { year: 2020, month: 10, price: 13637 },
    { year: 2020, month: 11, price: 19484 },
    { year: 2020, month: 12, price: 29152 },
    
    // 2021
    { year: 2021, month: 1, price: 34569 },
    { year: 2021, month: 2, price: 46234 },
    { year: 2021, month: 3, price: 58962 },
    { year: 2021, month: 4, price: 57081 },
    { year: 2021, month: 5, price: 36885 },
    { year: 2021, month: 6, price: 34796 },
    { year: 2021, month: 7, price: 39920 },
    { year: 2021, month: 8, price: 46979 },
    { year: 2021, month: 9, price: 43752 },
    { year: 2021, month: 10, price: 62629 },
    { year: 2021, month: 11, price: 57330 },
    { year: 2021, month: 12, price: 47019 },
    
    // 2022
    { year: 2022, month: 1, price: 38438 },
    { year: 2022, month: 2, price: 43107 },
    { year: 2022, month: 3, price: 45775 },
    { year: 2022, month: 4, price: 38322 },
    { year: 2022, month: 5, price: 31672.9 },
    { year: 2022, month: 6, price: 18797.2 },
    { year: 2022, month: 7, price: 23908.8 },
    { year: 2022, month: 8, price: 20286.3 },
    { year: 2022, month: 9, price: 19473.3 },
    { year: 2022, month: 10, price: 20473.3 },
    { year: 2022, month: 11, price: 17158.1 },
    { year: 2022, month: 12, price: 16590.7 },
    
    // 2023
    { year: 2023, month: 1, price: 23181.8 },
    { year: 2023, month: 2, price: 23158.9 },
    { year: 2023, month: 3, price: 28441.6 },
    { year: 2023, month: 4, price: 29351.3 },
    { year: 2023, month: 5, price: 27095.1 },
    { year: 2023, month: 6, price: 30377.2 },
    { year: 2023, month: 7, price: 29238.3 },
    { year: 2023, month: 8, price: 25988.8 },
    { year: 2023, month: 9, price: 26918.5 },
    { year: 2023, month: 10, price: 34588.5 },
    { year: 2023, month: 11, price: 37744.5 },
    { year: 2023, month: 12, price: 42025.1 },
    
    // 2024
    { year: 2024, month: 1, price: 42620.4 },
    { year: 2024, month: 2, price: 61247.4 },
    { year: 2024, month: 3, price: 69655.3 },
    { year: 2024, month: 4, price: 60184.4 },
    { year: 2024, month: 5, price: 67658.9 },
    { year: 2024, month: 6, price: 60064 },
    { year: 2024, month: 7, price: 64927 },
    { year: 2024, month: 8, price: 58776.8 },
    { year: 2024, month: 9, price: 63686.5 },
    { year: 2024, month: 10, price: 70363 },
    { year: 2024, month: 11, price: 97373.8 },
    { year: 2024, month: 12, price: 93359.3 },
    
    // 2025 (projected/future data from CSV)
    { year: 2025, month: 1, price: 101597 },
    { year: 2025, month: 2, price: 84128.3 },
    { year: 2025, month: 3, price: 82586.6 },
    { year: 2025, month: 4, price: 94410.8 },
    { year: 2025, month: 5, price: 104584 },
    { year: 2025, month: 6, price: 107173 },
    { year: 2025, month: 7, price: 116308 },
    { year: 2025, month: 8, price: 116617 }
  ];

  // Convert historical data with original precise positioning
  const getHistoricalDataForChart = (startYear, endYear) => {
    const historicalPoints = [];
    
    HISTORICAL_BITCOIN_PRICES.forEach(entry => {
      if (entry.price > 0) {
        // Position price at the precise monthly position
        const yearPosition = entry.year + (entry.month - 0.5) / 12;
        
        // Filter data to show only within the selected range
        if (yearPosition >= startYear && yearPosition <= endYear) {
          historicalPoints.push({
            x: yearPosition,
            y: entry.price
          });
        }
      }
    });
    
    // Sort by year to ensure proper line drawing
    historicalPoints.sort((a, b) => a.x - b.x);
    
    return historicalPoints;
  };

  // Create combined interpolated + future data for simulation lines
  const createCombinedSimulationData = (rows, historicalTimePoints) => {
    const combinedData = [];
    const lastHistoricalYear = historicalTimePoints.length > 0 ? 
      Math.max(...historicalTimePoints.map(p => p.x)) : 2025;
    
    // Part 1: Interpolated data to match historical timeline (up to last historical point)
    historicalTimePoints.forEach(timePoint => {
      const targetYear = timePoint.x;
      
      // Find surrounding simulation years
      let lowerRow = null;
      let upperRow = null;
      
      for (let i = 0; i < rows.length - 1; i++) {
        if (rows[i].year <= targetYear && rows[i + 1].year >= targetYear) {
          lowerRow = rows[i];
          upperRow = rows[i + 1];
          break;
        }
      }
      
      if (lowerRow && upperRow) {
        // Linear interpolation
        const ratio = (targetYear - lowerRow.year) / (upperRow.year - lowerRow.year);
        
        const interpolatedRow = {
          x: targetYear,
          supportPrice: lowerRow.supportPrice + ratio * (upperRow.supportPrice - lowerRow.supportPrice),
          maxLoanPossible: lowerRow.maxLoanPossible + ratio * (upperRow.maxLoanPossible - lowerRow.maxLoanPossible),
          totalDebt: lowerRow.totalDebt + ratio * (upperRow.totalDebt - lowerRow.totalDebt),
          remainingBtc: lowerRow.remainingBtc + ratio * (upperRow.remainingBtc - lowerRow.remainingBtc)
        };
        
        combinedData.push(interpolatedRow);
      } else if (rows.length === 1) {
        // Single point case
        combinedData.push({
          x: targetYear,
          supportPrice: rows[0].supportPrice,
          maxLoanPossible: rows[0].maxLoanPossible,
          totalDebt: rows[0].totalDebt,
          remainingBtc: rows[0].remainingBtc
        });
      }
    });
    
    // Part 2: Add annual simulation data for years beyond historical data
    rows.forEach(row => {
      if (row.year > lastHistoricalYear) {
        combinedData.push({
          x: row.year,
          supportPrice: row.supportPrice,
          maxLoanPossible: row.maxLoanPossible,
          totalDebt: row.totalDebt,
          remainingBtc: row.remainingBtc
        });
      }
    });
    
    // Sort by year to ensure proper line drawing
    combinedData.sort((a, b) => a.x - b.x);
    
    return combinedData;
  };

  // DOM Elements Cache
  const elements = {
    modeLoanBtn: document.getElementById('modeLoan'),
    modeSellBtn: document.getElementById('modeSell'),
    exampleBtn: document.getElementById('exampleBtn'),
    modeFixedWithdrawalBtn: document.getElementById('modeFixedWithdrawal'),
    modeOptimizedWithdrawalBtn: document.getElementById('modeOptimizedWithdrawal'),
    btcAmountInput: document.getElementById('btcAmount'),
    ltvInput: document.getElementById('ltv'),
    interestRateInput: document.getElementById('interestRate'),
    inflationRateInput: document.getElementById('inflationRate'),
    annualWithdrawalInput: document.getElementById('annualWithdrawal'),
    safetyMarginInput: document.getElementById('safetyMargin'),
    minWithdrawalInput: document.getElementById('minWithdrawal'),
    maximizeSafetyMarginBtn: document.getElementById('maximizeSafetyMarginBtn'),
    startYearInput: document.getElementById('startYear'),
    endYearInput: document.getElementById('endYear'),
    startYearValueSpan: document.getElementById('startYearValue'),
    endYearValueSpan: document.getElementById('endYearValue'),
    ltvValueSpan: document.getElementById('ltvValue'),
    interestRateValueSpan: document.getElementById('interestRateValue'),
    inflationRateValueSpan: document.getElementById('inflationRateValue'),
    safetyMarginValueSpan: document.getElementById('safetyMarginValue'),
    resultsTableHeader: document.getElementById('resultsTableHeader'),
    resultsTableBody: document.getElementById('resultsTableBody'),
    targetContainer: document.getElementById('targetContainer'),
    targetUnusedVsPeakFinalInput: document.getElementById('targetUnusedVsPeakFinal'),
    targetDescriptionEl: document.getElementById('targetDescription'),
    chartTitleEl: document.getElementById('chartTitle'),
    tableTitleEl: document.getElementById('tableTitle'),
    tableSubtitle: document.getElementById('tableSubtitle'),
    btcAmountLabel: document.getElementById('btcAmountLabel'),
    loanParams: document.getElementById('loanParams'),
    fixedWithdrawalControls: document.getElementById('fixedWithdrawalControls'),
    optimizedWithdrawalControls: document.getElementById('optimizedWithdrawalControls'),
    calculateSafeCollateralBtn: document.getElementById('calculateSafeCollateralBtn'),
    calculateSafeWithdrawalBtn: document.getElementById('calculateSafeWithdrawalBtn'),
    mainChartCtx: document.getElementById('mainChart').getContext('2d'),
    // Tax-related elements
    taxControls: document.getElementById('taxControls'),
    taxRateInput: document.getElementById('taxRate'),
    taxRateValueSpan: document.getElementById('taxRateValue'),
    taxRateWarning: document.getElementById('taxRateWarning'),
    purchasePriceInput: document.getElementById('purchasePrice'),
    carryoverPeriodInput: document.getElementById('carryoverPeriod'),
    // Remaining Amount elements
    remainingAmountInput: document.getElementById('remainingAmount'),
    remainingAmountBTCBtn: document.getElementById('remainingAmountBTC'),
    remainingAmountUSDBtn: document.getElementById('remainingAmountUSD')
  };

  // State
  let mainChart;
  let simulationMode = 'loan';
  let withdrawalMode = 'fixed'; // 'fixed' or 'optimized'
  let remainingAmountMode = 'BTC'; // 'BTC' or 'USD'
  const priceCache = {}; // Memoization for powerLawPrice
  let isAutoUpdating = false; // Flag to prevent infinite loops

  // Utils
  const formatCurrency = (value) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
  const formatBTC = (value) => (isFinite(value) ? value.toFixed(8) : '0') + ' BTC';
  const formatBTCPlain = (value) => (isFinite(value) ? value.toFixed(8) : '0');

  const powerLawPrice = (days) => {
    if (priceCache[days] !== undefined) return priceCache[days];
    const price = (1.0117e-17 * Math.pow(days, 5.82)) * 0.42;
    priceCache[days] = price;
    return price;
  };

  const binarySearchMinSafe = (low, high, checkUnsafeFn) => {
    let best = high;
    for (let k = 0; k < BINARY_SEARCH_ITERATIONS; k++) {
      const mid = (low + high) / 2;
      if (!checkUnsafeFn(mid)) { // safe
        best = mid;
        high = mid;
      } else { // unsafe
        low = mid;
      }
    }
    return best;
  };

  const binarySearchMaxSafe = (low, high, checkUnsafeFn) => {
    let best = low;
    for (let k = 0; k < BINARY_SEARCH_ITERATIONS; k++) {
      const mid = (low + high) / 2;
      if (!checkUnsafeFn(mid)) { // safe
        best = mid;
        low = mid;
      } else { // unsafe
        high = mid;
      }
    }
    return best;
  };

  const getDaysSinceGenesis = (year) => {
    const date = new Date(year, 0, 1);
    return Math.floor((date - GENESIS_DATE) / 86400000);
  };

  const precomputePrices = (startYear, simulationYears) => {
    const prices = [];
    for (let i = 0; i <= simulationYears; i++) {
      const days = getDaysSinceGenesis(startYear + i);
      prices.push(powerLawPrice(days));
    }
    return prices;
  };

  // Core Computations
  const computeLoanRows = (btcAmount, startYear, simulationYears) => {
    const ltvFrac = Math.max(0, parseInt(elements.ltvInput.value) || 0) / 100;
    const interestRate = Math.max(0, parseFloat(elements.interestRateInput.value) || 0) / 100;
    const inflationRate = Math.max(0, parseFloat(elements.inflationRateInput.value) || 0) / 100;
    const prices = precomputePrices(startYear, simulationYears);

    let withdrawals;
    if (withdrawalMode === 'optimized') {
      withdrawals = ltvFrac === 0 ? Array(simulationYears + 1).fill(0) : calculateOptimizedWithdrawals(btcAmount, startYear, simulationYears, prices);
    } else {
      const fixedAmount = Math.max(0, parseFloat(elements.annualWithdrawalInput.value) || 0);
      withdrawals = Array(simulationYears + 1).fill(fixedAmount);
    }

    let totalDebt = 0;
    const rows = [];
    for (let i = 0; i <= simulationYears; i++) {
      const supportPrice = prices[i]; // Always calculate support price regardless of LTV
      const baseWithdrawal = withdrawals[i];
      const adjustedWithdrawal = baseWithdrawal * Math.pow(1 + inflationRate, i);
      
      if (ltvFrac > 0) {
        const debtBeforeInterest = totalDebt + adjustedWithdrawal;
        const interestForYear = debtBeforeInterest * interestRate;
        totalDebt = debtBeforeInterest + interestForYear;
      } else {
        // When LTV is 0, no debt accumulates
        totalDebt = 0;
      }

      const requiredBtcCollateral = (supportPrice > 0 && ltvFrac > 0) ? (totalDebt / (supportPrice * ltvFrac)) : 0;
      const maxLoanPossible = supportPrice * btcAmount * ltvFrac;

      rows.push({
        i,
        year: startYear + i,
        supportPrice, // Always present regardless of LTV
        totalDebt,
        interestForYear: ltvFrac > 0 ? (totalDebt - (totalDebt / (1 + interestRate))) : 0,
        requiredBtcCollateral,
        maxLoanPossible,
        baseWithdrawal,
        adjustedWithdrawal
      });
    }
    return rows;
  };

  const computeSellRows = (btcAmount, startYear, simulationYears) => {
    const inflationRate = Math.max(0, parseFloat(elements.inflationRateInput.value) || 0) / 100;
    const initialAnnualWithdrawal = Math.max(0, parseFloat(elements.annualWithdrawalInput.value) || 0);
    const taxRate = Math.max(0, parseInt(elements.taxRateInput?.value) || 0) / 100;
    const purchasePrice = Math.max(0, parseFloat(elements.purchasePriceInput?.value) || 0);
    const carryoverPeriod = parseInt(elements.carryoverPeriodInput?.value) || 0;
    const prices = precomputePrices(startYear, simulationYears);

    // Calculate remaining amount target in BTC
    const remainingAmount = Math.max(0, parseFloat(elements.remainingAmountInput?.value) || 0);
    let targetRemainingBtc = 0;
    
    if (remainingAmount > 0) {
      if (remainingAmountMode === 'BTC') {
        targetRemainingBtc = remainingAmount;
      } else { // USD
        // Calculate future value considering inflation
        const finalYear = simulationYears;
        const futureValue = remainingAmount * Math.pow(1 + inflationRate, finalYear);
        const finalPrice = prices[finalYear];
        targetRemainingBtc = finalPrice > 0 ? (futureValue / finalPrice) : 0;
      }
    }

    let remainingBtc = btcAmount;
    let carryoverLosses = []; // Array of {amount, expiryYear}
    const rows = [];

    for (let i = 0; i <= simulationYears; i++) {
      const currentYear = startYear + i;
      const supportPrice = prices[i];
      const usdToWithdraw = initialAnnualWithdrawal * Math.pow(1 + inflationRate, i);
      
      // Check if we need to preserve remaining amount for final year
      const isLastYear = (i === simulationYears);
      const availableBtc = isLastYear ? (remainingBtc - targetRemainingBtc) : remainingBtc;
      
      // Calculate BTC needed for main withdrawal
      const btcNeededForWithdrawal = supportPrice > 0 ? (usdToWithdraw / supportPrice) : Infinity;
      
      let btcSold = 0;
      let btcSoldForTaxes = 0;
      let taxWithdrawal = 0;
      let expiredLosses = 0;
      let depleted = false;

      // Remove expired carryover losses
      if (carryoverPeriod > 0) {
        const beforeExpiry = carryoverLosses.length;
        carryoverLosses = carryoverLosses.filter(loss => {
          if (currentYear > loss.expiryYear) {
            expiredLosses += loss.amount;
            return false;
          }
          return true;
        });
      }

      if (availableBtc >= btcNeededForWithdrawal) {
        btcSold = btcNeededForWithdrawal;
        
        // Calculate taxes if tax rate > 0
        if (taxRate > 0 && supportPrice > 0) {
          const gainPerBtc = supportPrice - purchasePrice;
          let totalCapitalGain = btcSold * gainPerBtc;
          
          if (gainPerBtc < 0) {
            // Capital loss - add to carryover
            const lossAmount = Math.abs(totalCapitalGain);
            const expiryYear = carryoverPeriod === 0 ? Infinity : (currentYear + carryoverPeriod);
            carryoverLosses.push({ amount: lossAmount, expiryYear });
          } else if (gainPerBtc > 0) {
            // Capital gain - offset with carryover losses
            let availableLosses = carryoverLosses.reduce((sum, loss) => sum + loss.amount, 0);
            let offsetGain = Math.max(0, totalCapitalGain - availableLosses);
            
            // Apply carryover losses (FIFO)
            let remainingGainToOffset = totalCapitalGain;
            carryoverLosses = carryoverLosses.filter(loss => {
              if (remainingGainToOffset <= 0) return true;
              
              if (loss.amount <= remainingGainToOffset) {
                remainingGainToOffset -= loss.amount;
                return false; // Remove this loss (fully used)
              } else {
                loss.amount -= remainingGainToOffset;
                remainingGainToOffset = 0;
                return true; // Keep partial loss
              }
            });
            
            // Calculate taxes on net gain
            if (offsetGain > 0) {
              const baseTaxes = offsetGain * taxRate;
              
              // Calculate additional BTC needed to pay taxes
              // Solve: btcForTaxes * supportPrice = baseTaxes + (btcForTaxes * gainPerBtc * taxRate)
              // btcForTaxes * (supportPrice - gainPerBtc * taxRate) = baseTaxes
              const denominator = supportPrice - (gainPerBtc * taxRate);
              
              if (denominator > 0) {
                btcSoldForTaxes = baseTaxes / denominator;
                taxWithdrawal = btcSoldForTaxes * supportPrice;
              }
            }
          }
        }
        
        // Check if we have enough BTC for withdrawal + taxes
        const totalBtcNeeded = btcSold + btcSoldForTaxes;
        
        if (availableBtc >= totalBtcNeeded) {
          remainingBtc -= totalBtcNeeded;
        } else {
          // Not enough BTC - sell what we can
          btcSold = availableBtc;
          btcSoldForTaxes = 0;
          taxWithdrawal = 0;
          remainingBtc -= btcSold;
          depleted = true;
        }
      } else {
        // Not enough BTC for full withdrawal
        btcSold = Math.max(0, availableBtc);
        btcSoldForTaxes = 0;
        taxWithdrawal = 0;
        remainingBtc -= btcSold;
        depleted = true;
      }

      rows.push({
        i,
        year: currentYear,
        supportPrice,
        usdToWithdraw,
        btcSold,
        btcSoldForTaxes,
        taxWithdrawal,
        expiredLosses,
        remainingBtc,
        depleted
      });
    }
    
    return rows;
  };

  // Optimized Computations
  const calculateOptimizedWithdrawals = (btcAmount, startYear, simulationYears, prices, safetyMarginOverride = null, minWithdrawalOverride = null) => {
    const ltvFrac = Math.max(0, parseInt(elements.ltvInput.value) || 0) / 100;
    if (ltvFrac === 0 || btcAmount <= 0) return Array(simulationYears + 1).fill(0); // No withdrawals possible with 0 LTV or 0 BTC

    const interestRate = Math.max(0, parseFloat(elements.interestRateInput.value) || 0) / 100;
    const inflationRate = Math.max(0, parseFloat(elements.inflationRateInput.value) || 0) / 100;
    const safetyMargin = safetyMarginOverride ?? (parseFloat(elements.safetyMarginInput.value) || 0);
    const minWithdrawal = minWithdrawalOverride ?? (parseFloat(elements.minWithdrawalInput.value) || 0);
    const safetyFactor = (100 - safetyMargin) / 100;

    const withdrawals = [];
    let totalDebt = 0;

    for (let currentYear = 0; currentYear <= simulationYears; currentYear++) {
      let maxWithdrawal = binarySearchMaxSafe(0, 1e7, (testWithdrawal) => {
        let testDebt = totalDebt;
        let wouldLiquidate = false;

        for (let futureYear = currentYear; futureYear <= simulationYears; futureYear++) {
          const price = prices[futureYear];
          const maxCapacity = price * btcAmount * ltvFrac;

          const withdrawal = (futureYear === currentYear) ? testWithdrawal : (withdrawals[futureYear] ?? testWithdrawal);
          const adjustedWithdrawal = withdrawal * Math.pow(1 + inflationRate, futureYear);
          testDebt += adjustedWithdrawal;
          testDebt *= (1 + interestRate);

          if (testDebt > maxCapacity + EPS) {
            wouldLiquidate = true;
            break;
          }
        }
        return wouldLiquidate;
      });

      let safeWithdrawal = maxWithdrawal * safetyFactor;
      safeWithdrawal = Math.max(safeWithdrawal, minWithdrawal);
      withdrawals[currentYear] = safeWithdrawal;

      const adjustedWithdrawal = safeWithdrawal * Math.pow(1 + inflationRate, currentYear);
      totalDebt += adjustedWithdrawal;
      totalDebt *= (1 + interestRate);
    }

    return withdrawals;
  };

  // Check Functions
  const runLoanUnsafeCheck = (btcAmount, annualWithdrawal, startYear, simulationYears) => {
    const ltvFrac = Math.max(0, parseInt(elements.ltvInput.value) || 0) / 100;
    if (ltvFrac === 0 || btcAmount <= 0 || annualWithdrawal <= 0) return false; // No loan possible with 0 LTV

    const interestRate = Math.max(0, parseFloat(elements.interestRateInput.value) || 0) / 100;
    const inflationRate = Math.max(0, parseFloat(elements.inflationRateInput.value) || 0) / 100;
    const prices = precomputePrices(startYear, simulationYears);

    let totalDebt = 0;
    for (let i = 0; i <= simulationYears; i++) {
      const price = prices[i];
      const maxLoanPossible = price * btcAmount * ltvFrac;
      const withdrawal = annualWithdrawal * Math.pow(1 + inflationRate, i);
      totalDebt += withdrawal;
      totalDebt *= (1 + interestRate);
      if (totalDebt > maxLoanPossible + EPS) return true;
    }
    return false;
  };

  const runSellDepleted = (btcAmount, annualWithdrawal, startYear, simulationYears) => {
    if (btcAmount <= 0 || annualWithdrawal <= 0) return false;

    const inflationRate = Math.max(0, parseFloat(elements.inflationRateInput.value) || 0) / 100;
    const taxRate = Math.max(0, parseInt(elements.taxRateInput?.value) || 0) / 100;
    const purchasePrice = Math.max(0, parseFloat(elements.purchasePriceInput?.value) || 0);
    const prices = precomputePrices(startYear, simulationYears);

    // Calculate remaining amount target in BTC
    const remainingAmount = Math.max(0, parseFloat(elements.remainingAmountInput?.value) || 0);
    let targetRemainingBtc = 0;
    
    if (remainingAmount > 0) {
      if (remainingAmountMode === 'BTC') {
        targetRemainingBtc = remainingAmount;
      } else { // USD
        // Calculate future value considering inflation
        const futureValue = remainingAmount * Math.pow(1 + inflationRate, simulationYears);
        const finalPrice = prices[simulationYears];
        targetRemainingBtc = finalPrice > 0 ? (futureValue / finalPrice) : 0;
      }
    }

    let remainingBtc = btcAmount;
    for (let i = 0; i <= simulationYears; i++) {
      const price = prices[i];
      if (price <= 0) return true;
      
      const usd = annualWithdrawal * Math.pow(1 + inflationRate, i);
      let btcNeed = usd / price;
      
      // Add BTC needed for taxes if tax rate > 0
      if (taxRate > 0) {
        const gainPerBtc = price - purchasePrice;
        if (gainPerBtc > 0) {
          // Calculate additional BTC needed for taxes
          const baseTaxes = btcNeed * gainPerBtc * taxRate;
          const denominator = price - (gainPerBtc * taxRate);
          if (denominator > 0) {
            const additionalBtc = baseTaxes / denominator;
            btcNeed += additionalBtc;
          }
        }
      }

      // Check if we need to preserve remaining amount for final year
      const isLastYear = (i === simulationYears);
      const availableBtc = isLastYear ? (remainingBtc - targetRemainingBtc) : remainingBtc;
      
      if (availableBtc < btcNeed - 1e-12) return true;
      remainingBtc -= btcNeed;
    }
    return false;
  };

  const runOptimizedLoanUnsafeCheck = (btcAmount, startYear, simulationYears) => {
    const ltvFrac = Math.max(0, parseInt(elements.ltvInput.value) || 0) / 100;
    if (ltvFrac === 0 || btcAmount <= 0) return false; // No loan possible with 0 LTV

    const prices = precomputePrices(startYear, simulationYears);
    const withdrawals = calculateOptimizedWithdrawals(btcAmount, startYear, simulationYears, prices);

    let totalDebt = 0;
    const interestRate = Math.max(0, parseFloat(elements.interestRateInput.value) || 0) / 100;
    const inflationRate = Math.max(0, parseFloat(elements.inflationRateInput.value) || 0) / 100;

    for (let i = 0; i <= simulationYears; i++) {
      const adjustedWithdrawal = withdrawals[i] * Math.pow(1 + inflationRate, i);
      totalDebt += adjustedWithdrawal;
      totalDebt *= (1 + interestRate);

      const price = prices[i];
      const maxLoanPossible = price * btcAmount * ltvFrac;
      if (totalDebt > maxLoanPossible + EPS) return true;
    }
    return false;
  };

  // Auto Calculators
  const calculateSafeCollateral = () => {
    const startYear = parseInt(elements.startYearInput.value);
    const simulationYears = parseInt(elements.endYearInput.value) - startYear;
    const annualWithdrawal = Math.max(0, parseFloat(elements.annualWithdrawalInput.value) || 0);
    if (annualWithdrawal <= 0) {
      updateSimulation();
      return;
    }

    const best = binarySearchMinSafe(0, 1e6, (mid) => runLoanUnsafeCheck(mid, annualWithdrawal, startYear, simulationYears));
    elements.btcAmountInput.value = (Math.ceil(best * 1e8) / 1e8).toFixed(8);
    updateSimulation();
  };

  const calculateSafeCollateralOptimized = () => {
    const startYear = parseInt(elements.startYearInput.value);
    const simulationYears = parseInt(elements.endYearInput.value) - startYear;

    const best = binarySearchMinSafe(0, 1e6, (mid) => runOptimizedLoanUnsafeCheck(mid, startYear, simulationYears));
    elements.btcAmountInput.value = (Math.ceil(best * 1e8) / 1e8).toFixed(8);
    updateSimulation();
  };

  const autoCalcBtcForSell = () => {
    const startYear = parseInt(elements.startYearInput.value);
    const simulationYears = parseInt(elements.endYearInput.value) - startYear;
    const annualWithdrawal = Math.max(0, parseFloat(elements.annualWithdrawalInput.value) || 0);
    if (annualWithdrawal <= 0) {
      updateSimulation();
      return;
    }

    const best = binarySearchMinSafe(0, 1e6, (mid) => runSellDepleted(mid, annualWithdrawal, startYear, simulationYears));
    elements.btcAmountInput.value = (Math.ceil(best * 1e8) / 1e8).toFixed(8);
    updateSimulation();
  };

  const calculateSafeWithdrawal = () => {
    const startYear = parseInt(elements.startYearInput.value);
    const simulationYears = parseInt(elements.endYearInput.value) - startYear;
    const btc = Math.max(0, parseFloat(elements.btcAmountInput.value) || 0);
    if (btc <= 0) return;

    const checkUnsafeFn = (mid) => {
      if (simulationMode === 'loan') {
        return runLoanUnsafeCheck(btc, mid, startYear, simulationYears);
      } else {
        return runSellDepleted(btc, mid, startYear, simulationYears);
      }
    };

    const safe = binarySearchMaxSafe(0, 1e7, checkUnsafeFn);
    elements.annualWithdrawalInput.value = Math.floor(safe);
    updateSimulation();
  };

  const setExampleValues = () => {
    // Set example values
    elements.inflationRateInput.value = 7;
    elements.inflationRateValueSpan.textContent = '7.0';
    
    elements.ltvInput.value = 78;
    elements.ltvValueSpan.textContent = '78';
    
    elements.interestRateInput.value = 7;
    elements.interestRateValueSpan.textContent = '7.0';
    
    elements.annualWithdrawalInput.value = 10000;
    
    elements.startYearInput.value = 2025;
    elements.startYearValueSpan.textContent = '2025';
    
    elements.endYearInput.value = 2085;
    elements.endYearValueSpan.textContent = '2085';
    
    // Update year constraints
    elements.endYearInput.min = '2026';
    elements.startYearInput.max = '2084';
    
    // Calculate safe BTC for collateral based on these values
    if (simulationMode === 'loan') {
      if (withdrawalMode === 'fixed') {
        calculateSafeCollateral();
      } else {
        calculateSafeCollateralOptimized();
      }
    } else {
      autoCalcBtcForSell();
    }
  };

  const maximizeSafetyMargin = () => {
    if (simulationMode !== 'loan' || withdrawalMode !== 'optimized') return;

    const btcAmount = Math.max(0, parseFloat(elements.btcAmountInput.value) || 0);
    const startYear = parseInt(elements.startYearInput.value);
    const simulationYears = parseInt(elements.endYearInput.value) - startYear;
    if (btcAmount <= 0) return;

    const prices = precomputePrices(startYear, simulationYears);
    const inflationRate = Math.max(0, parseFloat(elements.inflationRateInput.value) || 0) / 100;

    let bestMargin = 0;
    let maxExtracted = 0;
    for (let margin = 0; margin <= 100; margin += 0.5) {
      const withdrawals = calculateOptimizedWithdrawals(btcAmount, startYear, simulationYears, prices, margin);
      let totalExtracted = 0;
      for (let i = 0; i <= simulationYears; i++) {
        totalExtracted += withdrawals[i] * Math.pow(1 + inflationRate, i);
      }
      if (totalExtracted > maxExtracted) {
        maxExtracted = totalExtracted;
        bestMargin = margin;
      }
    }

    elements.safetyMarginInput.value = bestMargin;
    elements.safetyMarginValueSpan.textContent = bestMargin.toFixed(1);
    updateSimulation();
  };

  // Rendering
  const initializeChart = () => {
    if (mainChart) mainChart.destroy();
    mainChart = new Chart(elements.mainChartCtx, {
      type: 'line',
      data: { labels: [], datasets: [] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        scales: {},
        plugins: { tooltip: { callbacks: {} } }
      }
    });
  };

  const updateCalculateSafeBtcButtonLabel = () => {
    if (simulationMode === 'loan' && withdrawalMode === 'optimized') {
      elements.calculateSafeCollateralBtn.innerHTML = `
        <div class="leading-tight text-center">
          <div class="font-medium">Calculate Safe Collateral</div>
          <div class="text-xs opacity-80">Wait a little</div>
        </div>
      `;
    } else {
      elements.calculateSafeCollateralBtn.textContent = 'Calculate Safe Collateral';
    }
  };

  const buildLoanTableRows = (rows, simulationYears, withdrawalMode) => {
    let globalPeak = 0;
    let firstPeakIndex = -1;
    rows.forEach((r, index) => {
      if (r.requiredBtcCollateral > globalPeak + EPS) {
        globalPeak = r.requiredBtcCollateral;
        firstPeakIndex = index;
      }
    });
    if (firstPeakIndex === -1) firstPeakIndex = simulationYears;

    let liquidationOccurred = false;
    let totalExtracted = 0;
    const tableRows = [];

    rows.forEach((r, i) => {
      const isLiquidated = r.totalDebt > r.maxLoanPossible + EPS;
      if (isLiquidated) liquidationOccurred = true;

      if (!liquidationOccurred) {
        totalExtracted += r.adjustedWithdrawal;
      }

      let unusedSigned;
      if (i < firstPeakIndex) {
        unusedSigned = r.requiredBtcCollateral - globalPeak;
      } else if (i === firstPeakIndex) {
        unusedSigned = 0;
      } else {
        unusedSigned = Math.max(0, globalPeak - r.requiredBtcCollateral);
      }

      const rowClass = liquidationOccurred ? 'row-red' : 'bg-white';
      const textColorClass = liquidationOccurred ? 'text-red-600' : 'text-slate-800';
      const colorUnused = unusedSigned < 0 ? 'text-red-600' : (unusedSigned > 0 ? 'text-emerald-700' : '');
      const ltvFrac = parseInt(elements.ltvInput.value) / 100 || 1;
      const addBtc = isLiquidated ? (r.totalDebt - r.maxLoanPossible) / (r.supportPrice * ltvFrac) : 0;

      const withdrawalClass = withdrawalMode === 'optimized' ? 'bg-blue-50' : '';

      tableRows.push(`
        <tr class="${rowClass} border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium ${liquidationOccurred ? 'text-red-700' : 'text-slate-900'}">${r.year}</td>
          <td class="px-6 py-4">${formatCurrency(r.supportPrice)}</td>
          <td class="px-6 py-4">${formatCurrency(r.maxLoanPossible)}</td>
          <td class="px-6 py-4 ${withdrawalClass} font-medium">${formatCurrency(r.adjustedWithdrawal)}</td>
          <td class="px-6 py-4 font-bold ${textColorClass}">${formatCurrency(r.totalDebt)}</td>
          <td class="px-6 py-4">${formatCurrency(r.interestForYear)}</td>
          <td class="px-6 py-4">${formatBTC(r.requiredBtcCollateral)}</td>
          <td class="px-6 py-4 ${colorUnused}">${unusedSigned < 0 ? '-' : (unusedSigned > 0 ? '+' : '')}${formatBTCPlain(Math.abs(unusedSigned))} BTC</td>
          <td class="px-6 py-4 font-bold ${textColorClass}">${addBtc > EPS ? formatBTC(addBtc) : 'None'}</td>
        </tr>
      `);
    });

    const strategyDescription = withdrawalMode === 'optimized' ? 'Optimized withdrawal strategy' : 'Fixed withdrawal strategy';
    elements.tableSubtitle.innerHTML = `<strong>TOTAL EXTRACTED: ${formatCurrency(totalExtracted)}</strong> <span class="text-sm text-slate-600 font-normal ml-2">- ${strategyDescription}</span>`;

    tableRows.push(`
      <tr class="bg-blue-100 border-t-2 border-blue-300 font-semibold">
        <td class="px-6 py-4 text-blue-800" colspan="3"><strong>TOTAL EXTRACTED:</strong></td>
        <td class="px-6 py-4 text-blue-800"><strong>${formatCurrency(totalExtracted)}</strong></td>
        <td colspan="5" class="px-6 py-4 text-xs text-blue-600">${strategyDescription}</td>
      </tr>
    `);

    return tableRows;
  };

  const buildSellTableRows = (rows) => {
    const taxRate = Math.max(0, parseInt(elements.taxRateInput?.value) || 0);
    const showTaxColumns = taxRate > 0;
    
    let totalWithdrawn = 0;
    let totalTaxes = 0;
    const tableRows = [];

    rows.forEach((r) => {
      const actualWithdrawn = r.btcSold * r.supportPrice;
      totalWithdrawn += actualWithdrawn;
      totalTaxes += r.taxWithdrawal || 0;

      const rowClass = r.depleted ? 'row-red' : 'bg-white';
      const balanceCell = r.depleted ? 'Depleted' : formatBTC(r.remainingBtc);
      const balanceColor = r.depleted ? 'text-red-600' : 'text-slate-800';

      let rowHtml = `
        <tr class="${rowClass} border-b hover:bg-stone-50">
          <td class="px-6 py-4 font-medium text-slate-900">${r.year}</td>
          <td class="px-6 py-4">${formatCurrency(r.supportPrice)}</td>
          <td class="px-6 py-4">${formatCurrency(r.usdToWithdraw)}</td>
          <td class="px-6 py-4">${formatBTC(r.btcSold)}</td>`;

      if (showTaxColumns) {
        const taxWithdrawal = r.taxWithdrawal || 0;
        const btcSoldForTaxes = r.btcSoldForTaxes || 0;
        const expiredLosses = r.expiredLosses || 0;
        
        rowHtml += `
          <td class="px-6 py-4">${formatCurrency(taxWithdrawal)}</td>
          <td class="px-6 py-4">${formatBTC(btcSoldForTaxes)}</td>
          <td class="px-6 py-4 ${expiredLosses > 0 ? 'text-red-600' : ''}">${expiredLosses > 0 ? '-' + formatCurrency(expiredLosses) : '$0.00'}</td>`;
      }

      rowHtml += `
          <td class="px-6 py-4 font-bold ${balanceColor}">${balanceCell}</td>
        </tr>
      `;

      tableRows.push(rowHtml);
    });

    if (showTaxColumns) {
      elements.tableSubtitle.innerHTML = `<strong>TOTAL WITHDRAWN: ${formatCurrency(totalWithdrawn)} - TOTAL TAXES: ${formatCurrency(totalTaxes)}</strong>`;
    } else {
      elements.tableSubtitle.innerHTML = `<strong>TOTAL WITHDRAWN (ACTUAL): ${formatCurrency(totalWithdrawn)}</strong>`;
    }

    // Summary row
    const summaryColspan = showTaxColumns ? 6 : 3;
    const summaryContent = showTaxColumns ? 
      `<strong>TOTAL WITHDRAWN: ${formatCurrency(totalWithdrawn)} - TOTAL TAXES: ${formatCurrency(totalTaxes)}</strong>` :
      `<strong>TOTAL WITHDRAWN (ACTUAL): ${formatCurrency(totalWithdrawn)}</strong>`;
    
    tableRows.push(`
      <tr class="bg-blue-100 border-t-2 border-blue-300 font-semibold">
        <td class="px-6 py-4 text-blue-800" colspan="2"><strong>TOTALS:</strong></td>
        <td class="px-6 py-4 text-blue-800">${summaryContent}</td>
        <td colspan="${showTaxColumns ? '4' : '1'}" class="px-6 py-4 text-xs text-blue-600">Actual amounts over the simulation period</td>
      </tr>
    `);

    return tableRows;
  };

  const configureLoanChart = (rows) => {
    const startYear = rows.length > 0 ? rows[0].year : 2025;
    const endYear = rows.length > 0 ? rows[rows.length - 1].year : 2085;
    const historicalData = getHistoricalDataForChart(startYear, endYear);
    
    mainChart.options.scales = {
      yPrice: { type: 'logarithmic', position: 'left', title: { display: true, text: 'BTC Price ($)' }, ticks: { callback: v => formatCurrency(v) } },
      yLoan:  { type: 'logarithmic', position: 'right', title: { display: true, text: 'Loan/Debt Amount ($)' }, ticks: { callback: v => formatCurrency(v) }, grid: { drawOnChartArea: false } },
      x: { 
        type: 'linear',
        position: 'bottom',
        ticks: { 
          maxRotation: 0, 
          minRotation: 0, 
          autoSkip: true, 
          maxTicksLimit: 15,
          callback: function(value) {
            return Math.floor(value);
          }
        }
      }
    };
    
    // Create combined data: interpolated (up to 2025) + annual (beyond 2025)
    const combinedSimData = createCombinedSimulationData(rows, historicalData);
    
    const datasets = [];
    
    // Add historical data first (all precise monthly points)
    if (historicalData.length > 0) {
      datasets.push({ 
        label: 'Historical Bitcoin Prices', 
        data: historicalData,
        borderColor: '#f59e0b', 
        backgroundColor: 'rgba(245,158,11,0.1)', 
        borderWidth: 2, 
        tension: 0.1, 
        fill: false, 
        pointRadius: 1, 
        pointHoverRadius: 4,
        yAxisID: 'yPrice' 
      });
    }
    
    // Add simulation lines with combined data (interpolated + future)
    if (combinedSimData.length > 0) {
      datasets.push({
        label: 'Power Law Support Price', 
        data: combinedSimData.map(d => ({ x: d.x, y: d.supportPrice })), 
        borderColor: '#10b981', 
        backgroundColor: 'rgba(16,185,129,0.1)', 
        borderWidth: 2, 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'yPrice' 
      });
      
      datasets.push({
        label: 'Maximum Possible Loan', 
        data: combinedSimData.map(d => ({ x: d.x, y: d.maxLoanPossible })), 
        borderColor: '#3b82f6', 
        backgroundColor: 'transparent', 
        borderWidth: 3, 
        borderDash: [5,5], 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'yLoan' 
      });
      
      datasets.push({
        label: 'Total Accumulated Debt', 
        data: combinedSimData.map(d => ({ x: d.x, y: d.totalDebt })), 
        borderColor: '#ef4444', 
        backgroundColor: 'rgba(239,68,68,0.1)', 
        borderWidth: 3, 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'yLoan' 
      });
    } else {
      // Fallback to original yearly data if no interpolation possible
      datasets.push({
        label: 'Power Law Support Price', 
        data: rows.map(r => ({ x: r.year, y: r.supportPrice })), 
        borderColor: '#10b981', 
        backgroundColor: 'rgba(16,185,129,0.1)', 
        borderWidth: 2, 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'yPrice' 
      });
      
      datasets.push({
        label: 'Maximum Possible Loan', 
        data: rows.map(r => ({ x: r.year, y: r.maxLoanPossible })), 
        borderColor: '#3b82f6', 
        backgroundColor: 'transparent', 
        borderWidth: 3, 
        borderDash: [5,5], 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'yLoan' 
      });
      
      datasets.push({
        label: 'Total Accumulated Debt', 
        data: rows.map(r => ({ x: r.year, y: r.totalDebt })), 
        borderColor: '#ef4444', 
        backgroundColor: 'rgba(239,68,68,0.1)', 
        borderWidth: 3, 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'yLoan' 
      });
    }
    
    mainChart.data = { datasets };
    
    // Configure tooltip for perfect alignment
    mainChart.options.plugins = {
      tooltip: {
        mode: 'index',
        intersect: false,
        callbacks: {
          title: function(context) {
            return 'Year: ' + context[0].parsed.x.toFixed(1);
          },
          label: function(context) {
            let label = context.dataset.label || '';
            if (label) {
              label += ': ';
            }
            if (context.dataset.yAxisID === 'yPrice') {
              label += formatCurrency(context.parsed.y);
            } else {
              label += formatCurrency(context.parsed.y);
            }
            return label;
          }
        }
      }
    };
  };

  const configureSellChart = (rows) => {
    const startYear = rows.length > 0 ? rows[0].year : 2025;
    const endYear = rows.length > 0 ? rows[rows.length - 1].year : 2085;
    const historicalData = getHistoricalDataForChart(startYear, endYear);
    
    mainChart.options.scales = {
      y: { type: 'linear', position: 'left', title: { display: true, text: 'Remaining BTC Balance' }, ticks: { callback: v => v.toFixed(2) + ' BTC' } },
      yPrice: { type: 'logarithmic', position: 'right', title: { display: true, text: 'BTC Price ($)' }, ticks: { callback: v => formatCurrency(v) }, grid: { drawOnChartArea: false } },
      x: { 
        type: 'linear',
        position: 'bottom',
        ticks: { 
          maxRotation: 0, 
          minRotation: 0, 
          autoSkip: true, 
          maxTicksLimit: 15,
          callback: function(value) {
            return Math.floor(value);
          }
        }
      }
    };
    
    // Create combined data: interpolated (up to 2025) + annual (beyond 2025)
    const combinedSimData = createCombinedSimulationData(rows, historicalData);
    
    const datasets = [];
    
    // Add historical data first (all precise monthly points)
    if (historicalData.length > 0) {
      datasets.push({ 
        label: 'Historical Bitcoin Prices', 
        data: historicalData,
        borderColor: '#f59e0b', 
        backgroundColor: 'rgba(245,158,11,0.1)', 
        borderWidth: 2, 
        tension: 0.1, 
        fill: false, 
        pointRadius: 1, 
        pointHoverRadius: 4,
        yAxisID: 'yPrice' 
      });
    }
    
    // Add simulation lines with combined data (interpolated + future)
    if (combinedSimData.length > 0) {
      datasets.push({
        label: 'Power Law Support Price', 
        data: combinedSimData.map(d => ({ x: d.x, y: d.supportPrice })), 
        borderColor: '#10b981', 
        backgroundColor: 'rgba(16,185,129,0.1)', 
        borderWidth: 2, 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'yPrice' 
      });
      
      datasets.push({
        label: 'Remaining BTC Balance', 
        data: combinedSimData.map(d => ({ x: d.x, y: d.remainingBtc })), 
        borderColor: '#ef4444', 
        backgroundColor: 'rgba(239,68,68,0.1)', 
        borderWidth: 3, 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'y' 
      });
    } else {
      // Fallback to original yearly data
      datasets.push({
        label: 'Power Law Support Price', 
        data: rows.map(r => ({ x: r.year, y: r.supportPrice })), 
        borderColor: '#10b981', 
        backgroundColor: 'rgba(16,185,129,0.1)', 
        borderWidth: 2, 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'yPrice' 
      });
      
      datasets.push({
        label: 'Remaining BTC Balance', 
        data: rows.map(r => ({ x: r.year, y: r.remainingBtc })), 
        borderColor: '#ef4444', 
        backgroundColor: 'rgba(239,68,68,0.1)', 
        borderWidth: 3, 
        tension: 0.4, 
        fill: false, 
        pointRadius: 0,
        pointHoverRadius: 4,
        yAxisID: 'y' 
      });
    }
    
    mainChart.data = { datasets };
    
    // Configure tooltip for perfect alignment
    mainChart.options.plugins = {
      tooltip: {
        mode: 'index',
        intersect: false,
        callbacks: {
          title: function(context) {
            return 'Year: ' + context[0].parsed.x.toFixed(1);
          },
          label: function(context) {
            let label = context.dataset.label || '';
            if (label) {
              label += ': ';
            }
            if (context.dataset.yAxisID === 'yPrice') {
              label += formatCurrency(context.parsed.y);
            } else if (context.dataset.yAxisID === 'y') {
              label += context.parsed.y.toFixed(2) + ' BTC';
            } else {
              label += formatCurrency(context.parsed.y);
            }
            return label;
          }
        }
      }
    };
  };

  const renderLoan = (btcAmount, startYear, simulationYears) => {
    elements.loanParams.classList.remove('hidden');
    elements.targetContainer.classList.remove('hidden');
    elements.taxControls.classList.add('hidden');
    elements.chartTitleEl.textContent = 'Debt vs. Capacity Projection';
    elements.tableTitleEl.textContent = 'Loan Calculation Details';
    elements.btcAmountLabel.textContent = 'BTC for Collateral';

    if (withdrawalMode === 'optimized') {
      elements.fixedWithdrawalControls.classList.add('hidden');
      elements.optimizedWithdrawalControls.classList.remove('hidden');
    } else {
      elements.fixedWithdrawalControls.classList.remove('hidden');
      elements.optimizedWithdrawalControls.classList.add('hidden');
    }

    const withdrawalHeader = withdrawalMode === 'optimized' ? 'Optimized Withdrawal ($)' : 'Annual Withdrawal ($)';

    elements.resultsTableHeader.innerHTML = `
      <tr>
        <th class="px-6 py-3">Year</th>
        <th class="px-6 py-3">Support Price ($)</th>
        <th class="px-6 py-3">Maximum Possible Loan ($)</th>
        <th class="px-6 py-3">${withdrawalHeader}</th>
        <th class="px-6 py-3">Total Debt ($)</th>
        <th class="px-6 py-3">Annual Interest ($)</th>
        <th class="px-6 py-3">Required BTC Collateral</th>
        <th class="px-6 py-3">Unused BTC vs Peak</th>
        <th class="px-6 py-3">Additional Collateral Required (BTC)</th>
      </tr>`;

    const rows = computeLoanRows(btcAmount, startYear, simulationYears);
    const tableRows = buildLoanTableRows(rows, simulationYears, withdrawalMode);
    elements.resultsTableBody.innerHTML = tableRows.join('');

    if (rows.length > 0) {
      const lastRow = rows[rows.length - 1];
      const globalPeak = rows.reduce((max, r) => Math.max(max, r.requiredBtcCollateral), 0);
      const finalUnused = globalPeak - lastRow.requiredBtcCollateral;
      elements.targetUnusedVsPeakFinalInput.value = finalUnused.toFixed(8);

      if (withdrawalMode === 'optimized') {
        elements.targetUnusedVsPeakFinalInput.readOnly = true;
        elements.targetUnusedVsPeakFinalInput.disabled = true;
        elements.targetUnusedVsPeakFinalInput.style.pointerEvents = 'none';
        elements.targetUnusedVsPeakFinalInput.style.backgroundColor = '#f3f4f6';
        elements.targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. Maybe it can go to the children :)';
      } else {
        elements.targetUnusedVsPeakFinalInput.readOnly = true;
        elements.targetUnusedVsPeakFinalInput.disabled = true;
        elements.targetUnusedVsPeakFinalInput.style.pointerEvents = 'none';
        elements.targetUnusedVsPeakFinalInput.style.backgroundColor = '#f3f4f6';
        elements.targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. Maybe it can go to the children :)';
      }
    }

    configureLoanChart(rows);
  };

  const renderSell = (btcAmount, startYear, simulationYears) => {
    elements.loanParams.classList.add('hidden');
    elements.targetContainer.classList.add('hidden');
    elements.chartTitleEl.textContent = 'Remaining BTC Balance Projection';
    elements.tableTitleEl.textContent = 'Sell Strategy Details';
    elements.btcAmountLabel.textContent = 'BTC to Sell';

    elements.fixedWithdrawalControls.classList.remove('hidden');
    elements.optimizedWithdrawalControls.classList.add('hidden');
    elements.taxControls.classList.remove('hidden');

    const taxRate = Math.max(0, parseInt(elements.taxRateInput?.value) || 0);
    const showTaxColumns = taxRate > 0;

    let headerHtml = `
      <tr>
        <th class="px-6 py-3">Year</th>
        <th class="px-6 py-3">Support Price ($)</th>
        <th class="px-6 py-3">Annual Withdrawal ($)</th>
        <th class="px-6 py-3">BTC Sold This Year</th>`;
    
    if (showTaxColumns) {
      headerHtml += `
        <th class="px-6 py-3">Annual Tax Withdrawal ($)</th>
        <th class="px-6 py-3">BTC Sold This Year For Taxes</th>
        <th class="px-6 py-3">Expired Capital Losses</th>`;
    }
    
    headerHtml += `
        <th class="px-6 py-3">Remaining BTC Balance</th>
      </tr>`;

    elements.resultsTableHeader.innerHTML = headerHtml;

    const rows = computeSellRows(btcAmount, startYear, simulationYears);
    const tableRows = buildSellTableRows(rows);
    elements.resultsTableBody.innerHTML = tableRows.join('');

    configureSellChart(rows);
  };

  const updateSimulation = () => {
    initializeChart();

    const btcAmount = Math.max(0, parseFloat(elements.btcAmountInput.value) || 0);
    const startYear = parseInt(elements.startYearInput.value);
    const simulationYears = parseInt(elements.endYearInput.value) - startYear;

    if (simulationMode === 'loan') {
      renderLoan(btcAmount, startYear, simulationYears);
    } else {
      renderSell(btcAmount, startYear, simulationYears);
    }

    updateCalculateSafeBtcButtonLabel();
    mainChart.update();
  };

  // Event Listeners Setup
  const setupEventListeners = () => {
    const updateSliderLabel = (input, span, isFloat = false) => {
      span.textContent = isFloat ? parseFloat(input.value).toFixed(1) : input.value;
    };

    elements.ltvInput.addEventListener('input', () => updateSliderLabel(elements.ltvInput, elements.ltvValueSpan));
    elements.interestRateInput.addEventListener('input', () => updateSliderLabel(elements.interestRateInput, elements.interestRateValueSpan, true));
    elements.inflationRateInput.addEventListener('input', () => updateSliderLabel(elements.inflationRateInput, elements.inflationRateValueSpan, true));
    elements.safetyMarginInput.addEventListener('input', () => updateSliderLabel(elements.safetyMarginInput, elements.safetyMarginValueSpan, true));
    
    // Tax rate slider (only available in sell mode)
    if (elements.taxRateInput && elements.taxRateValueSpan) {
      elements.taxRateInput.addEventListener('input', () => {
        updateSliderLabel(elements.taxRateInput, elements.taxRateValueSpan);
        
        // Show/hide tax rate warning
        const taxRate = parseInt(elements.taxRateInput.value) || 0;
        if (elements.taxRateWarning) {
          if (taxRate > 0) {
            elements.taxRateWarning.classList.remove('hidden');
          } else {
            elements.taxRateWarning.classList.add('hidden');
          }
        }
      });
    }

    // Remaining Amount toggle buttons
    if (elements.remainingAmountBTCBtn && elements.remainingAmountUSDBtn) {
      elements.remainingAmountBTCBtn.addEventListener('click', () => {
        remainingAmountMode = 'BTC';
        elements.remainingAmountBTCBtn.classList.add('active');
        elements.remainingAmountUSDBtn.classList.remove('active');
        });

      elements.remainingAmountUSDBtn.addEventListener('click', () => {
        remainingAmountMode = 'USD';
        elements.remainingAmountUSDBtn.classList.add('active');
        elements.remainingAmountBTCBtn.classList.remove('active');
        });
    }

    elements.startYearInput.addEventListener('input', () => {
      updateSliderLabel(elements.startYearInput, elements.startYearValueSpan);
      const minEnd = parseInt(elements.startYearInput.value) + 1;
      elements.endYearInput.min = minEnd.toString();
      if (parseInt(elements.endYearInput.value) < minEnd) {
        elements.endYearInput.value = minEnd.toString();
        elements.endYearValueSpan.textContent = elements.endYearInput.value;
      }
      updateSimulation();
    });

    elements.endYearInput.addEventListener('input', () => {
      updateSliderLabel(elements.endYearInput, elements.endYearValueSpan);
      const newMaxForStart = parseInt(elements.endYearInput.value) - 1;
      elements.startYearInput.max = newMaxForStart.toString();
      const startVal = parseInt(elements.startYearInput.value);
      const minEnd = startVal + 1;
      if (parseInt(elements.endYearInput.value) < minEnd) {
        elements.endYearInput.value = minEnd.toString();
        elements.endYearValueSpan.textContent = elements.endYearInput.value;
      }
      updateSimulation();
    });

    // Existing change listeners for updateSimulation
    const simulationUpdateInputs = [
      elements.ltvInput, 
      elements.interestRateInput, 
      elements.inflationRateInput, 
      elements.safetyMarginInput, 
      elements.minWithdrawalInput
    ];
    
    // Add tax-related inputs if they exist
    if (elements.taxRateInput) {
      simulationUpdateInputs.push(elements.taxRateInput);
      // Also add the change event to handle warning display
      elements.taxRateInput.addEventListener('change', () => {
        const taxRate = parseInt(elements.taxRateInput.value) || 0;
        if (elements.taxRateWarning) {
          if (taxRate > 0) {
            elements.taxRateWarning.classList.remove('hidden');
          } else {
            elements.taxRateWarning.classList.add('hidden');
          }
        }
        updateSimulation();
      });
    }
    if (elements.purchasePriceInput) simulationUpdateInputs.push(elements.purchasePriceInput);
    if (elements.carryoverPeriodInput) simulationUpdateInputs.push(elements.carryoverPeriodInput);
simulationUpdateInputs.forEach(input => input.addEventListener('change', updateSimulation));

    // Special handlers for btcAmountInput and annualWithdrawalInput to avoid loops
    elements.btcAmountInput.addEventListener('change', () => {
      if (isAutoUpdating) return;
      isAutoUpdating = true;
      calculateSafeWithdrawal();
      updateSimulation();
      isAutoUpdating = false;
    });

    elements.annualWithdrawalInput.addEventListener('change', () => {
      if (isAutoUpdating) return;
      isAutoUpdating = true;
      if (simulationMode === 'loan') {
        if (withdrawalMode === 'fixed') calculateSafeCollateral();
        else calculateSafeCollateralOptimized();
      } else {
        autoCalcBtcForSell();
      }
      updateSimulation();
      isAutoUpdating = false;
    });

    elements.modeLoanBtn.addEventListener('click', () => {
      simulationMode = 'loan';
      withdrawalMode = 'fixed';
      elements.modeFixedWithdrawalBtn.classList.add('active');
      elements.modeOptimizedWithdrawalBtn.classList.remove('active');

      // Lock the Unused BTC field (same visuals as Optimized)
      elements.targetUnusedVsPeakFinalInput.readOnly = true;
      elements.targetUnusedVsPeakFinalInput.disabled = true;
      elements.targetUnusedVsPeakFinalInput.style.pointerEvents = 'none';
      elements.targetUnusedVsPeakFinalInput.style.backgroundColor = '#f3f4f6';
      elements.targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. Maybe it can go to the children :)';

      // Toggle main mode buttons
      elements.modeLoanBtn.classList.add('active');
      elements.modeSellBtn.classList.remove('active');
      
      // Hide tax controls
      elements.taxControls.classList.add('hidden');

      // Recalculate and render
      calculateSafeCollateral();
      updateSimulation();
    });

    elements.modeSellBtn.addEventListener('click', () => {
      simulationMode = 'sell';
      elements.modeSellBtn.classList.add('active');
      elements.modeLoanBtn.classList.remove('active');
      elements.taxControls.classList.remove('hidden');
      autoCalcBtcForSell();
      updateSimulation();
    });

    elements.modeFixedWithdrawalBtn.addEventListener('click', () => {
      withdrawalMode = 'fixed';
      elements.modeFixedWithdrawalBtn.classList.add('active');
      elements.modeOptimizedWithdrawalBtn.classList.remove('active');
      elements.targetUnusedVsPeakFinalInput.readOnly = true;
      elements.targetUnusedVsPeakFinalInput.disabled = true;
      elements.targetUnusedVsPeakFinalInput.style.pointerEvents = 'none';
      elements.targetUnusedVsPeakFinalInput.style.backgroundColor = '#f3f4f6';
      elements.targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. Maybe it can go to the children :)';
      updateSimulation();
    });

    elements.modeOptimizedWithdrawalBtn.addEventListener('click', () => {
      withdrawalMode = 'optimized';
      elements.modeOptimizedWithdrawalBtn.classList.add('active');
      elements.modeFixedWithdrawalBtn.classList.remove('active');
      elements.targetUnusedVsPeakFinalInput.readOnly = true;
      elements.targetUnusedVsPeakFinalInput.disabled = true;
      elements.targetUnusedVsPeakFinalInput.style.pointerEvents = 'none';
      elements.targetUnusedVsPeakFinalInput.style.backgroundColor = '#f3f4f6';
      elements.targetDescriptionEl.textContent = 'Shows BTC not used as collateral in the final year. Maybe it can go to the children :)';
      updateSimulation();
    });

    elements.maximizeSafetyMarginBtn.addEventListener('click', maximizeSafetyMargin);
    elements.calculateSafeWithdrawalBtn.addEventListener('click', calculateSafeWithdrawal);
    elements.exampleBtn.addEventListener('click', setExampleValues);

    elements.calculateSafeCollateralBtn.addEventListener('click', () => {
      if (simulationMode === 'loan') {
        if (withdrawalMode === 'fixed') calculateSafeCollateral();
        else calculateSafeCollateralOptimized();
      } else {
        autoCalcBtcForSell();
      }
    });

    elements.btcAmountLabel.addEventListener('click', () => {
      if (simulationMode === 'sell') autoCalcBtcForSell();
    });

    let applyTimeout;
    elements.targetUnusedVsPeakFinalInput.addEventListener('input', () => {
      if (simulationMode !== 'loan' || withdrawalMode !== 'fixed') return;
      const target = parseFloat(elements.targetUnusedVsPeakFinalInput.value);
      if (!isFinite(target)) return;

      const startYear = parseInt(elements.startYearInput.value);
      const simulationYears = parseInt(elements.endYearInput.value) - startYear;

      const rows = computeLoanRows(parseFloat(elements.btcAmountInput.value) || 0, startYear, simulationYears);
      const peak = rows.reduce((m, r) => Math.max(m, r.requiredBtcCollateral), 0);

      const desiredBtc = Math.max(0, peak + target);
      const currentBtc = parseFloat(elements.btcAmountInput.value) || 0;
      if (Math.abs(desiredBtc - currentBtc) > EPS) {
        if (applyTimeout) clearTimeout(applyTimeout);
        applyTimeout = setTimeout(() => {
          elements.btcAmountInput.value = (Math.round(desiredBtc * 1e8) / 1e8).toFixed(8);
          updateSimulation();
        }, 30);
      }
    });
  };

  // Initialization
  window.onload = () => {
    elements.startYearInput.min =  2009;
    elements.startYearInput.value = 2009;
    elements.endYearInput.min =  2010;
    elements.endYearInput.max = 2085;
    elements.endYearInput.value = 2025;
    elements.startYearInput.max = elements.endYearInput.value - 1;

    elements.startYearValueSpan.textContent = elements.startYearInput.value;
    elements.endYearValueSpan.textContent = elements.endYearInput.value;
    elements.ltvValueSpan.textContent = elements.ltvInput.value;
    elements.interestRateValueSpan.textContent = parseFloat(elements.interestRateInput.value).toFixed(1);
    elements.inflationRateValueSpan.textContent = parseFloat(elements.inflationRateInput.value).toFixed(1);
    elements.safetyMarginValueSpan.textContent = parseFloat(elements.safetyMarginInput.value).toFixed(1);

    // Initialize tax-related values if elements exist
    if (elements.taxRateValueSpan) {
      elements.taxRateValueSpan.textContent = elements.taxRateInput?.value || '0';
    }

    // Hide tax controls and warning initially (default mode is loan)
    if (elements.taxControls) {
      elements.taxControls.classList.add('hidden');
    }
    if (elements.taxRateWarning) {
      elements.taxRateWarning.classList.add('hidden');
    }

    // Initialize remaining amount toggle (default to BTC)
    if (elements.remainingAmountBTCBtn) {
      elements.remainingAmountBTCBtn.classList.add('active');
    }
    if (elements.remainingAmountUSDBtn) {
      elements.remainingAmountUSDBtn.classList.remove('active');
    }

    setupEventListeners();
    initializeChart();
    // Don't auto-calculate with default values of 0
    updateSimulation();
  };
})();
</script>

</body>
</html>
